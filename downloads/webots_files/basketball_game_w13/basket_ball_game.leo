<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20250516134116.1"><vh>@settings</vh>
<v t="leo.20250516134116.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20250516134116.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20250516134008.2"><vh>basket_ball_game</vh></v>
<v t="leo.20250516135203.1"><vh>About STL file format</vh></v>
<v t="leo.20250516135801.1"><vh>About OBJ file format</vh></v>
<v t="leo.20250516134045.1"><vh>importer</vh></v>
<v t="leo.20250516134148.1"><vh>imported files</vh>
<v t="leo.20250516134148.2"><vh>path: ./</vh>
<v t="leo.20250516134148.3"><vh>@clean basket_ball_radius.py</vh></v>
<v t="leo.20250516134148.4"><vh>@clean degree_to_radian.py</vh></v>
<v t="leo.20250516134148.5"><vh>path: ./controllers</vh>
<v t="leo.20250516134148.6"><vh>path: ./controllers/feed_ball</vh>
<v t="leo.20250516134148.7"><vh>@clean feed_ball.py</vh>
<v t="leo.20250516134148.8"><vh>function: generate_valid_def_name</vh></v>
<v t="leo.20250516134148.9"><vh>function: generate_random_color</vh></v>
<v t="leo.20250516134148.10"><vh>function: create_sphere</vh></v>
</v>
</v>
<v t="leo.20250516134148.11"><vh>path: ./controllers/robot_controller</vh>
<v t="leo.20250516134148.12"><vh>@clean robot_controller.py</vh>
<v t="leo.20250516134148.13"><vh>function: run_robot</vh></v>
</v>
</v>
<v t="leo.20250516134148.14"><vh>path: ./controllers/send_command_from_emitter</vh>
<v t="leo.20250516134148.15"><vh>@clean send_command_from_emitter.py</vh>
<v t="leo.20250516134148.16"><vh>function: run_supervisor</vh></v>
</v>
</v>
<v t="leo.20250516134148.17"><vh>path: ./controllers/sensor</vh>
<v t="leo.20250516134148.18"><vh>@clean sensor.py</vh>
<v t="leo.20250516134148.19"><vh>function: run_robot</vh></v>
</v>
<v t="leo.20250516134148.20"><vh>@clean sensor_before_add_keyboard_action.py</vh>
<v t="leo.20250516134148.21"><vh>function: run_robot</vh></v>
</v>
</v>
<v t="leo.20250516134148.22"><vh>path: ./controllers/sensor_km</vh>
<v t="leo.20250516134148.23"><vh>@clean sensor_km.py</vh>
<v t="leo.20250516134148.24"><vh>function: run_robot</vh></v>
</v>
</v>
<v t="leo.20250516134148.25"><vh>path: ./controllers/sensor_supervisor</vh>
<v t="leo.20250516134148.26"><vh>@clean sensor_supervisor.py</vh>
<v t="leo.20250516134148.27"><vh>function: run_supervisor</vh></v>
</v>
</v>
</v>
<v t="leo.20250516134148.29"><vh>path: ./programs</vh>
<v t="leo.20250516134148.30"><vh>@clean split_stl_to_obj_scale.py</vh>
<v t="leo.20250516134148.31"><vh>class STLConverter</vh>
<v t="leo.20250516134148.32"><vh>STLConverter.__init__</vh></v>
<v t="leo.20250516134148.33"><vh>STLConverter._check_if_binary</vh></v>
<v t="leo.20250516134148.34"><vh>STLConverter._read_binary_stl</vh></v>
<v t="leo.20250516134148.35"><vh>STLConverter._read_ascii_stl</vh></v>
<v t="leo.20250516134148.36"><vh>STLConverter._split_by_connected_components</vh></v>
<v t="leo.20250516134148.37"><vh>STLConverter._write_binary_stl</vh></v>
<v t="leo.20250516134148.38"><vh>STLConverter._write_obj</vh></v>
<v t="leo.20250516134148.39"><vh>STLConverter.split_and_convert</vh></v>
</v>
</v>
<v t="leo.20250516134148.40"><vh>@clean split_stl_to_obj_scale2.py</vh>
<v t="leo.20250516134148.41"><vh>class STLConverter</vh>
<v t="leo.20250516134148.42"><vh>STLConverter.__init__</vh></v>
<v t="leo.20250516134148.43"><vh>STLConverter._check_if_binary</vh></v>
<v t="leo.20250516134148.44"><vh>STLConverter._read_binary_stl</vh></v>
<v t="leo.20250516134148.45"><vh>STLConverter._read_ascii_stl</vh></v>
<v t="leo.20250516134148.46"><vh>STLConverter._split_by_connected_components</vh></v>
<v t="leo.20250516134148.47"><vh>STLConverter._write_binary_stl</vh></v>
<v t="leo.20250516134148.48"><vh>STLConverter._write_obj</vh></v>
<v t="leo.20250516134148.49"><vh>STLConverter.split_and_convert</vh></v>
</v>
</v>
<v t="leo.20250516134148.50"><vh>@clean split_stl_to_obj_scale2_w_mtl.py</vh>
<v t="leo.20250516134148.51"><vh>class STLConverter</vh>
<v t="leo.20250516134148.52"><vh>STLConverter.__init__</vh></v>
<v t="leo.20250516134148.53"><vh>STLConverter._check_if_binary</vh></v>
<v t="leo.20250516134148.54"><vh>STLConverter._read_binary_stl</vh></v>
<v t="leo.20250516134148.55"><vh>STLConverter._read_ascii_stl</vh></v>
<v t="leo.20250516134148.56"><vh>STLConverter._split_by_connected_components</vh></v>
<v t="leo.20250516134148.57"><vh>STLConverter._write_binary_stl</vh></v>
<v t="leo.20250516134148.58"><vh>STLConverter._write_mtl</vh></v>
<v t="leo.20250516134148.59"><vh>STLConverter._write_obj</vh></v>
<v t="leo.20250516134148.60"><vh>STLConverter.split_and_convert</vh></v>
</v>
</v>
</v>
<v t="leo.20250516134148.61"><vh>path: ./solvespace</vh>
<v t="leo.20250516134148.62"><vh>@clean split_stl_to_obj_scale2_w_mtl.py</vh>
<v t="leo.20250516134148.63"><vh>class STLConverter</vh>
<v t="leo.20250516134148.64"><vh>STLConverter.__init__</vh></v>
<v t="leo.20250516134148.65"><vh>STLConverter._check_if_binary</vh></v>
<v t="leo.20250516134148.66"><vh>STLConverter._read_binary_stl</vh></v>
<v t="leo.20250516134148.67"><vh>STLConverter._read_ascii_stl</vh></v>
<v t="leo.20250516134148.68"><vh>STLConverter._split_by_connected_components</vh></v>
<v t="leo.20250516134148.69"><vh>STLConverter._write_binary_stl</vh></v>
<v t="leo.20250516134148.70"><vh>STLConverter._write_mtl</vh></v>
<v t="leo.20250516134148.71"><vh>STLConverter._write_obj</vh></v>
<v t="leo.20250516134148.72"><vh>STLConverter.split_and_convert</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20250516134008.2">以下 Python 程式包含拆分 .stl 組立件, 以及 Webots 場景在建立投籃機遊戲系統所需的控制程式</t>
<t tx="leo.20250516134045.1">@language python
c.recursiveImport(
    dir_ = './',
    kind = '@clean',        # or '@file' or '@auto'
    safe_at_file = False,   # True: generate @@clean nodes.
    theTypes = ['.py']        # Same as ['.py']
)</t>
<t tx="leo.20250516134116.1"></t>
<t tx="leo.20250516134116.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20250516134116.3">horizontal: body pane to the left
vertical: body pane on the botton

this settings is not working on 6.8.3 any more
use Window - Toggle-Split-Direction</t>
<t tx="leo.20250516134148.1"></t>
<t tx="leo.20250516134148.10"># 定義一個函數，用於創建球的節點
def create_sphere(supervisor, position):
    def_name = generate_valid_def_name()  # 獲取唯一的 DEF 名稱
    r, g, b = generate_random_color()  # 獲取隨機顏色
    sphere_string = f"""
    DEF {def_name} Solid {{
      translation {position[0]} {position[1]} {position[2]}  # 設置球的初始位置
      children [
        Shape {{
          geometry Sphere {{
            radius {sphere_radius}  # 設置球的半徑
          }}
          appearance Appearance {{
            material Material {{
              diffuseColor {r} {g} {b}  # 隨機設置球的顏色
            }}
          }}
        }}
      ]
      physics Physics {{
        mass 0.1  # 設置球的質量
      }}
      boundingObject Sphere {{
        radius {sphere_radius}  # 設置碰撞邊界為球形
      }}
      contactMaterial "ball"  # 設定 contactMaterial 欄位為 "ball"
    }}
    """
    root = supervisor.getRoot()  # 獲取模擬場景的根節點
    children_field = root.getField("children")  # 獲取根節點的子節點字段
    children_field.importMFNodeFromString(-1, sphere_string)  # 將新創建的球節點加入模擬
    print(f"Sphere created at position {position} with DEF name: {def_name} and color: ({r:.2f}, {g:.2f}, {b:.2f})")
</t>
<t tx="leo.20250516134148.11"></t>
<t tx="leo.20250516134148.12">@path ./controllers/robot_controller
from controller import Robot, Receiver

@others
if __name__ == "__main__":
    run_robot()
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.13">def run_robot():
    # Create the Robot instance
    robot = Robot()

    # Get simulation time step
    timestep = int(robot.getBasicTimeStep())

    # Get the motor device
    motor = robot.getDevice("motor1")  # Replace "motor1" with the actual motor name
    if motor is None:
        print("Error: Could not find motor device")
        return

    # Get the receiver for receiving commands
    receiver = robot.getDevice("receiver")  # Ensure the receiver is defined in your world file
    if receiver is None:
        print("Error: Could not find receiver device")
        return
    receiver.enable(timestep)

    # Main control loop
    while robot.step(timestep) != -1:
        # Process received messages
        if receiver.getQueueLength() &gt; 0:
            message = receiver.getString() # Receive the message
            receiver.nextPacket()  # Move to the next packet

            # Parse the command message
            if message.startswith("SET_POSITION:"):
                position = float(message.split(":")[1])  # Extract the desired position
                motor.setPosition(position)  # Set the motor position
</t>
<t tx="leo.20250516134148.14"></t>
<t tx="leo.20250516134148.15">@path ./controllers/send_command_from_emitter
from controller import Supervisor

@others
if __name__ == "__main__":
    run_supervisor()
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.16">def run_supervisor():
    # Create the Supervisor instance
    supervisor = Supervisor()

    # Get simulation time step
    timestep = int(supervisor.getBasicTimeStep())

    # Get the emitter for sending commands
    emitter = supervisor.getDevice("emitter")  # Ensure the emitter is defined in your world file
    if emitter is None:
        print("Error: Could not find emitter device")
        return

    # Main control loop
    while supervisor.step(timestep) != -1:

        # Send motor position command to the robot
        motor_position = 38 * 3.14159 / 180  # Motor position in radians
        message = f"SET_POSITION:{motor_position}"  # Construct the command message
        emitter.send(message.encode("utf-8"))  # Send the message via the emitter
</t>
<t tx="leo.20250516134148.17"></t>
<t tx="leo.20250516134148.18">@path ./controllers/sensor
from controller import Robot, DistanceSensor

@others
if __name__ == "__main__":
    run_robot()
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.19">def run_robot():
    # Create the Robot instance
    robot = Robot()

    # Get simulation time step
    timestep = int(robot.getBasicTimeStep())

    # Get the DistanceSensor device
    sensor = robot.getDevice('sensor')
    sensor.enable(timestep)
    score = 0
    last_score_time = 0
    cooldown = 1.0

    # Get motor and keyboard devices
    motor = robot.getDevice('motor1')
    keyboard = robot.getKeyboard()
    keyboard.enable(timestep)

    # Set initial motor position
    initial_position = 0.0  # Assuming initial position is 0

    # Main control loop
    while robot.step(timestep) != -1:
        # Read DistanceSensor value
        sensor_value = sensor.getValue()
        current_time = robot.getTime()
        #print(sensor_value)
        # Check if the ball blocks the sensor (you may need to adjust the threshold based on your sensor's range)
        if sensor_value &gt; 200 and (current_time - last_score_time) &gt; cooldown:
            score +=2
            print("得分")
        # Motor control (existing functionality)
        motor.setPosition(38 * 3.14159 / 180)
</t>
<t tx="leo.20250516134148.2"></t>
<t tx="leo.20250516134148.20">@path ./controllers/sensor
from controller import Robot, DistanceSensor

@others
if __name__ == "__main__":
    run_robot()
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.21">def run_robot():
    # Create the Robot instance
    robot = Robot()

    # Get simulation time step
    timestep = int(robot.getBasicTimeStep())

    # Get the DistanceSensor device
    sensor = robot.getDevice('sensor')
    sensor.enable(timestep)
    score = 0
    last_score_time = 0
    cooldown = 1.0

    # Get motor and keyboard devices
    motor = robot.getDevice('motor1')
    keyboard = robot.getKeyboard()
    keyboard.enable(timestep)

    # Set initial motor position
    initial_position = 0.0  # Assuming initial position is 0

    # Main control loop
    while robot.step(timestep) != -1:
        # Read DistanceSensor value
        sensor_value = sensor.getValue()
        current_time = robot.getTime()
        #print(sensor_value)
        # Check if the ball blocks the sensor (you may need to adjust the threshold based on your sensor's range)
        if sensor_value &gt; 200 and (current_time - last_score_time) &gt; cooldown:
            score +=2
            print("得分")
        # Motor control (existing functionality)
        motor.setPosition(38 * 3.14159 / 180)
</t>
<t tx="leo.20250516134148.22"></t>
<t tx="leo.20250516134148.23">@path ./controllers/sensor_km
from controller import Robot, Keyboard

@others
if __name__ == "__main__":
    run_robot()
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.24">def run_robot():
    # Create the Robot instance
    robot = Robot()

    # Get simulation time step
    timestep = int(robot.getBasicTimeStep())

    # Get the keyboard device
    keyboard = robot.getKeyboard()
    keyboard.enable(timestep)

    # Get motor and sensor devices
    motor = robot.getDevice('motor1')
    sensor = robot.getDevice('sensor')
    sensor.enable(timestep)

    # Set initial motor position
    initial_position = 0.0  # Assuming initial position is 0
    motor.setPosition(initial_position)
    initial = True

    # Main control loop
    while robot.step(timestep) != -1:
        # Read the DistanceSensor value
        sensor_value = sensor.getValue()

        # Read the pressed key
        key = keyboard.getKey()

        if initial:
            motor.setPosition(38 * 3.14159 / 180)  # Set position to desired angle
            initial = False
        
        # Reset joint1 when 'm' is pressed
        if key == ord('M'):
            motor.setPosition(initial_position)  # Reset to initial position
            print("Joint1 reset to initial position")
            
        if key == ord('K'):
            motor.setPosition(38 * 3.14159 / 180)  # Set position to desired angle
            print("Joint1 set to desired angle")
</t>
<t tx="leo.20250516134148.25"></t>
<t tx="leo.20250516134148.26">@path ./controllers/sensor_supervisor
from controller import Supervisor

@others
if __name__ == "__main__":
    run_supervisor()
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.27">def run_supervisor():
    # Create the Supervisor instance
    supervisor = Supervisor()

    # Get simulation time step
    timestep = int(supervisor.getBasicTimeStep())

    # Get the emitter for sending commands
    emitter = supervisor.getDevice("emitter")  # Ensure the emitter is defined in your world file
    if emitter is None:
        print("Error: Could not find emitter device")
        return

    # Get the ball node to calculate distance
    ball_node = supervisor.getFromDef("ball")  # Replace "ball" with the ball's DEF name
    if ball_node is None:
        print("Error: Could not find ball with DEF name 'ball'")
        return

    # Get the sensor node (to calculate distance from the sensor to the ball)
    sensor_node = supervisor.getFromDef("MySensor")  # Replace "MySensor" with the sensor's DEF name
    if sensor_node is None:
        print("Error: Could not find sensor with DEF name 'MySensor'")
        return

    # Initialize scoring logic
    score = 0
    last_score_time = 0
    cooldown = 1.0  # Cooldown time in seconds

    # Main control loop
    while supervisor.step(timestep) != -1:
        # Get the positions of the sensor and the ball
        sensor_position = sensor_node.getPosition()  # Get the sensor's global position
        ball_position = ball_node.getPosition()  # Get the ball's global position

        # Calculate the distance between the sensor and the ball
        distance = ((sensor_position[0] - ball_position[0]) ** 2 +
                    (sensor_position[1] - ball_position[1]) ** 2 +
                    (sensor_position[2] - ball_position[2]) ** 2) ** 0.5

        # Simulate a sensor value based on distance
        sensor_value = 1000 - (distance * 1000)  # Example: Convert distance to an approximate sensor value
        sensor_value = max(sensor_value, 0)  # Ensure sensor value is not negative

        # Scoring logic
        current_time = supervisor.getTime()
        if sensor_value &gt; 200 and (current_time - last_score_time) &gt; cooldown:
            score += 2
            last_score_time = current_time
            print(f"得分! Score: {score}")

        # Send motor position command to the robot
        motor_position = 38 * 3.14159 / 180  # Motor position in radians
        message = f"SET_POSITION:{motor_position}"  # Construct the command message
        emitter.send(message.encode("utf-8"))  # Send the message via the emitter
</t>
<t tx="leo.20250516134148.29"></t>
<t tx="leo.20250516134148.3">@path .
"""
利用圓周反算籃球半徑
"""
import math
basket_ball_circumference = 75 # cm
basket_ball_radius = basket_ball_circumference/(2.0*math.pi)
print(basket_ball_radius)
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.30">@path ./programs
import struct
import numpy as np
from pathlib import Path

@others
# 使用範例
if __name__ == "__main__":
    # 設定 scale=0.001 將單位從 mm 轉換為 m
    converter = STLConverter("fourbar_assembly.stl", scale=0.01)
    num_parts = converter.split_and_convert()
    print(f"\n總共處理了 {num_parts} 個零件")
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.31">class STLConverter:
    @others
</t>
<t tx="leo.20250516134148.32">def __init__(self, filename, scale=0.001):  # 新增 scale 參數，預設 0.001 將 mm 轉換為 m
    self.filename = filename
    self.scale = scale
    self.is_binary = self._check_if_binary()
</t>
<t tx="leo.20250516134148.33">        
def _check_if_binary(self):
    """檢查 STL 檔案是否為二進制格式"""
    with open(self.filename, 'rb') as f:
        header = f.read(5).decode('utf-8', errors='ignore')
        return not header.startswith('solid')
</t>
<t tx="leo.20250516134148.34">    
def _read_binary_stl(self):
    """讀取二進制 STL 檔案"""
    with open(self.filename, 'rb') as f:
        f.seek(80)
        triangle_count = struct.unpack('I', f.read(4))[0]
            
        triangles = []
        normals = []
            
        for _ in range(triangle_count):
            nx, ny, nz = struct.unpack('fff', f.read(12))
            normals.append([nx, ny, nz])
                
            triangle = []
            for _ in range(3):
                x, y, z = struct.unpack('fff', f.read(12))
                # 在讀取頂點時進行縮放
                triangle.append([x * self.scale, y * self.scale, z * self.scale])
            triangles.append(triangle)
                
            f.seek(2, 1)
                
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.35">    
def _read_ascii_stl(self):
    """讀取 ASCII STL 檔案"""
    triangles = []
    normals = []
    current_triangle = []
        
    with open(self.filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
                    
            parts = line.split()
            if not parts:
                continue
                
            if parts[0] == 'facet' and parts[1] == 'normal':
                normals.append([float(parts[2]), float(parts[3]), float(parts[4])])
            elif parts[0] == 'vertex':
                # 在讀取頂點時進行縮放
                current_triangle.append([
                    float(parts[1]) * self.scale,
                    float(parts[2]) * self.scale,
                    float(parts[3]) * self.scale
                ])
            elif parts[0] == 'endfacet':
                if current_triangle:
                    triangles.append(current_triangle)
                    current_triangle = []
        
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.36">    
def _split_by_connected_components(self, triangles, normals):
    """使用連通分量分割模型"""
    vertex_to_triangle = {}
    for i, triangle in enumerate(triangles):
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple in vertex_to_triangle:
                vertex_to_triangle[vertex_tuple].append(i)
            else:
                vertex_to_triangle[vertex_tuple] = [i]
        
    visited = set()
    components = []
        
    def dfs(triangle_idx):
        component = []
        stack = [triangle_idx]
            
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                component.append(current)
                    
                for vertex in triangles[current]:
                    vertex_tuple = tuple(vertex)
                    for neighbor in vertex_to_triangle[vertex_tuple]:
                        if neighbor not in visited:
                            stack.append(neighbor)
            
        return component
        
    for i in range(len(triangles)):
        if i not in visited:
            component = dfs(i)
            components.append(component)
        
    return components
</t>
<t tx="leo.20250516134148.37">    
def _write_binary_stl(self, filename, triangles, normals):
    """寫入二進制 STL 檔案"""
    with open(filename, 'wb') as f:
        f.write(b'\x00' * 80)
        f.write(struct.pack('I', len(triangles)))
            
        for triangle, normal in zip(triangles, normals):
            f.write(struct.pack('fff', *normal))
            for vertex in triangle:
                f.write(struct.pack('fff', *vertex))
            f.write(struct.pack('H', 0))
</t>
<t tx="leo.20250516134148.38">def _write_obj(self, filename, triangles, normals):
    """寫入 OBJ 檔案"""
    vertex_dict = {}
    vertex_list = []
    normal_list = []
    faces = []
        
    for triangle, normal in zip(triangles, normals):
        face_indices = []
            
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple not in vertex_dict:
                vertex_dict[vertex_tuple] = len(vertex_list) + 1
                vertex_list.append(vertex)
            face_indices.append(vertex_dict[vertex_tuple])
            
        normal_list.append(normal)
        faces.append(face_indices)
        
    with open(filename, 'w') as f:
        for v in vertex_list:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
            
        for n in normal_list:
            f.write(f"vn {n[0]} {n[1]} {n[2]}\n")
            
        for i, face in enumerate(faces):
            f.write(f"f {face[0]}//{i+1} {face[1]}//{i+1} {face[2]}//{i+1}\n")
</t>
<t tx="leo.20250516134148.39">    
def split_and_convert(self):
    """分割 STL 檔案並轉換為 OBJ 格式"""
    if self.is_binary:
        triangles, normals = self._read_binary_stl()
    else:
        triangles, normals = self._read_ascii_stl()
        
    components = self._split_by_connected_components(triangles, normals)
        
    output_dir = Path('split_parts')
    output_dir.mkdir(exist_ok=True)
        
    for i, component in enumerate(components):
        component_triangles = triangles[component]
        component_normals = normals[component]
            
        base_name = f"part_{i + 1}"
        stl_filename = output_dir / f"{base_name}.stl"
        obj_filename = output_dir / f"{base_name}.obj"
            
        #self._write_binary_stl(stl_filename, component_triangles, component_normals)
        self._write_obj(obj_filename, component_triangles, component_normals)
            
        print(f"已儲存零件 {i + 1} 到:")
        #print(f"  STL: {stl_filename}")
        print(f"  OBJ: {obj_filename}")
        
    return len(components)
</t>
<t tx="leo.20250516134148.4">@path .
"""
配合 CAD 系統用於三角函數中角度與徑度轉換
"""
import math
degree = math.pi/180
print(30*degree)
print(-55.12*degree)
print(90.53*degree)
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.40">@path ./programs
import struct
import numpy as np
from pathlib import Path

@others
# 使用範例
if __name__ == "__main__":
    # 設定 scale=0.001 將單位從 mm 轉換為 m
    converter = STLConverter("fourbar_linkage_design_w_assembly.stl", scale=0.01)
    num_parts = converter.split_and_convert()
    print(f"\n總共處理了 {num_parts} 個零件")
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.41">class STLConverter:
    @others
</t>
<t tx="leo.20250516134148.42">def __init__(self, filename, scale=0.001):  # 新增 scale 參數，預設 0.001 將 mm 轉換為 m
    self.filename = filename
    self.scale = scale
    self.is_binary = self._check_if_binary()
</t>
<t tx="leo.20250516134148.43">        
def _check_if_binary(self):
    """檢查 STL 檔案是否為二進制格式"""
    with open(self.filename, 'rb') as f:
        header = f.read(5).decode('utf-8', errors='ignore')
        return not header.startswith('solid')
</t>
<t tx="leo.20250516134148.44">    
def _read_binary_stl(self):
    """讀取二進制 STL 檔案"""
    with open(self.filename, 'rb') as f:
        f.seek(80)
        triangle_count = struct.unpack('I', f.read(4))[0]
            
        triangles = []
        normals = []
            
        for _ in range(triangle_count):
            nx, ny, nz = struct.unpack('fff', f.read(12))
            normals.append([nx, ny, nz])
                
            triangle = []
            for _ in range(3):
                x, y, z = struct.unpack('fff', f.read(12))
                # 在讀取頂點時進行縮放
                triangle.append([x * self.scale, y * self.scale, z * self.scale])
            triangles.append(triangle)
                
            f.seek(2, 1)
                
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.45">    
def _read_ascii_stl(self):
    """讀取 ASCII STL 檔案"""
    triangles = []
    normals = []
    current_triangle = []
        
    with open(self.filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
                    
            parts = line.split()
            if not parts:
                continue
                
            if parts[0] == 'facet' and parts[1] == 'normal':
                normals.append([float(parts[2]), float(parts[3]), float(parts[4])])
            elif parts[0] == 'vertex':
                # 在讀取頂點時進行縮放
                current_triangle.append([
                    float(parts[1]) * self.scale,
                    float(parts[2]) * self.scale,
                    float(parts[3]) * self.scale
                ])
            elif parts[0] == 'endfacet':
                if current_triangle:
                    triangles.append(current_triangle)
                    current_triangle = []
        
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.46">    
def _split_by_connected_components(self, triangles, normals):
    """使用連通分量分割模型"""
    vertex_to_triangle = {}
    for i, triangle in enumerate(triangles):
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple in vertex_to_triangle:
                vertex_to_triangle[vertex_tuple].append(i)
            else:
                vertex_to_triangle[vertex_tuple] = [i]
        
    visited = set()
    components = []
        
    def dfs(triangle_idx):
        component = []
        stack = [triangle_idx]
            
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                component.append(current)
                    
                for vertex in triangles[current]:
                    vertex_tuple = tuple(vertex)
                    for neighbor in vertex_to_triangle[vertex_tuple]:
                        if neighbor not in visited:
                            stack.append(neighbor)
            
        return component
        
    for i in range(len(triangles)):
        if i not in visited:
            component = dfs(i)
            components.append(component)
        
    return components
</t>
<t tx="leo.20250516134148.47">    
def _write_binary_stl(self, filename, triangles, normals):
    """寫入二進制 STL 檔案"""
    with open(filename, 'wb') as f:
        f.write(b'\x00' * 80)
        f.write(struct.pack('I', len(triangles)))
            
        for triangle, normal in zip(triangles, normals):
            f.write(struct.pack('fff', *normal))
            for vertex in triangle:
                f.write(struct.pack('fff', *vertex))
            f.write(struct.pack('H', 0))
</t>
<t tx="leo.20250516134148.48">def _write_obj(self, filename, triangles, normals):
    """寫入 OBJ 檔案"""
    vertex_dict = {}
    vertex_list = []
    normal_list = []
    faces = []
        
    for triangle, normal in zip(triangles, normals):
        face_indices = []
            
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple not in vertex_dict:
                vertex_dict[vertex_tuple] = len(vertex_list) + 1
                vertex_list.append(vertex)
            face_indices.append(vertex_dict[vertex_tuple])
            
        normal_list.append(normal)
        faces.append(face_indices)
        
    with open(filename, 'w') as f:
        for v in vertex_list:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
            
        for n in normal_list:
            f.write(f"vn {n[0]} {n[1]} {n[2]}\n")
            
        for i, face in enumerate(faces):
            f.write(f"f {face[0]}//{i+1} {face[1]}//{i+1} {face[2]}//{i+1}\n")
</t>
<t tx="leo.20250516134148.49">    
def split_and_convert(self):
    """分割 STL 檔案並轉換為 OBJ 格式"""
    if self.is_binary:
        triangles, normals = self._read_binary_stl()
    else:
        triangles, normals = self._read_ascii_stl()
        
    components = self._split_by_connected_components(triangles, normals)
        
    output_dir = Path('split_parts')
    output_dir.mkdir(exist_ok=True)
        
    for i, component in enumerate(components):
        component_triangles = triangles[component]
        component_normals = normals[component]
            
        base_name = f"part_{i + 1}"
        stl_filename = output_dir / f"{base_name}.stl"
        obj_filename = output_dir / f"{base_name}.obj"
            
        #self._write_binary_stl(stl_filename, component_triangles, component_normals)
        self._write_obj(obj_filename, component_triangles, component_normals)
            
        print(f"已儲存零件 {i + 1} 到:")
        #print(f"  STL: {stl_filename}")
        print(f"  OBJ: {obj_filename}")
        
    return len(components)
</t>
<t tx="leo.20250516134148.5"></t>
<t tx="leo.20250516134148.50">@path ./programs
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on: 2025-02-09 15:40:51 UTC
Author: mdecycu
Description: STL file converter that splits STL files into multiple OBJ files with MTL materials
"""

import struct
import numpy as np
from pathlib import Path

@others
# 直接轉換指定的 STL 檔案
try:
    # 指定要轉換的 STL 檔案名稱和縮放比例
    stl_file = "shooter_assembly.stl"
    scale = 0.01  # 縮放比例，可以根據需要調整

    # 創建轉換器實例並執行轉換
    converter = STLConverter(stl_file, scale=scale)
    num_parts = converter.split_and_convert()
    print(f"\n總共處理了 {num_parts} 個零件")
except Exception as e:
    print(f"錯誤: {e}")
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.51">class STLConverter:
    @others
</t>
<t tx="leo.20250516134148.52">def __init__(self, filename, scale=0.001):  # 新增 scale 參數，預設 0.001 將 mm 轉換為 m
    self.filename = filename
    self.scale = scale
    self.is_binary = self._check_if_binary()
</t>
<t tx="leo.20250516134148.53">        
def _check_if_binary(self):
    """檢查 STL 檔案是否為二進制格式"""
    with open(self.filename, 'rb') as f:
        header = f.read(5).decode('utf-8', errors='ignore')
        return not header.startswith('solid')
</t>
<t tx="leo.20250516134148.54">    
def _read_binary_stl(self):
    """讀取二進制 STL 檔案"""
    with open(self.filename, 'rb') as f:
        f.seek(80)
        triangle_count = struct.unpack('I', f.read(4))[0]
            
        triangles = []
        normals = []
            
        for _ in range(triangle_count):
            nx, ny, nz = struct.unpack('fff', f.read(12))
            normals.append([nx, ny, nz])
                
            triangle = []
            for _ in range(3):
                x, y, z = struct.unpack('fff', f.read(12))
                # 在讀取頂點時進行縮放
                triangle.append([x * self.scale, y * self.scale, z * self.scale])
            triangles.append(triangle)
                
            f.seek(2, 1)
                
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.55">    
def _read_ascii_stl(self):
    """讀取 ASCII STL 檔案"""
    triangles = []
    normals = []
    current_triangle = []
        
    with open(self.filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
                    
            parts = line.split()
            if not parts:
                continue
                
            if parts[0] == 'facet' and parts[1] == 'normal':
                normals.append([float(parts[2]), float(parts[3]), float(parts[4])])
            elif parts[0] == 'vertex':
                # 在讀取頂點時進行縮放
                current_triangle.append([
                    float(parts[1]) * self.scale,
                    float(parts[2]) * self.scale,
                    float(parts[3]) * self.scale
                ])
            elif parts[0] == 'endfacet':
                if current_triangle:
                    triangles.append(current_triangle)
                    current_triangle = []
        
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.56">    
def _split_by_connected_components(self, triangles, normals):
    """使用連通分量分割模型"""
    vertex_to_triangle = {}
    for i, triangle in enumerate(triangles):
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple in vertex_to_triangle:
                vertex_to_triangle[vertex_tuple].append(i)
            else:
                vertex_to_triangle[vertex_tuple] = [i]
        
    visited = set()
    components = []
        
    def dfs(triangle_idx):
        component = []
        stack = [triangle_idx]
            
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                component.append(current)
                    
                for vertex in triangles[current]:
                    vertex_tuple = tuple(vertex)
                    for neighbor in vertex_to_triangle[vertex_tuple]:
                        if neighbor not in visited:
                            stack.append(neighbor)
            
        return component
        
    for i in range(len(triangles)):
        if i not in visited:
            component = dfs(i)
            components.append(component)
        
    return components
</t>
<t tx="leo.20250516134148.57">    
def _write_binary_stl(self, filename, triangles, normals):
    """寫入二進制 STL 檔案"""
    with open(filename, 'wb') as f:
        f.write(b'\x00' * 80)
        f.write(struct.pack('I', len(triangles)))
            
        for triangle, normal in zip(triangles, normals):
            f.write(struct.pack('fff', *normal))
            for vertex in triangle:
                f.write(struct.pack('fff', *vertex))
            f.write(struct.pack('H', 0))
</t>
<t tx="leo.20250516134148.58">def _write_mtl(self, filename, material_name):
    """寫入 MTL 材質檔案"""
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"newmtl {material_name}\n")
        f.write("Ka 0.2 0.2 0.2\n")  # Ambient color
        f.write("Kd 0.8 0.8 0.8\n")  # Diffuse color
        f.write("Ks 0.5 0.5 0.5\n")  # Specular color
        f.write("Ns 50.0\n")         # Specular exponent
        f.write("d 1.0\n")           # Transparency (1.0 = opaque)
        f.write("illum 2\n")         # Illumination model
</t>
<t tx="leo.20250516134148.59">def _write_obj(self, filename, triangles, normals):
    """寫入 OBJ 檔案"""
    vertex_dict = {}
    vertex_list = []
    normal_list = []
    faces = []
        
    for triangle, normal in zip(triangles, normals):
        face_indices = []
            
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple not in vertex_dict:
                vertex_dict[vertex_tuple] = len(vertex_list) + 1
                vertex_list.append(vertex)
            face_indices.append(vertex_dict[vertex_tuple])
            
        normal_list.append(normal)
        faces.append(face_indices)
        
    # Generate material name from the obj filename
    material_name = filename.stem
    # Create MTL filename using Path
    mtl_filename = filename.with_suffix('.mtl')
        
    # Write OBJ file
    with open(filename, 'w', encoding='utf-8') as f:
        # Reference the MTL file
        f.write(f"mtllib {mtl_filename.name}\n")
        f.write(f"usemtl {material_name}\n\n")
            
        for v in vertex_list:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
            
        for n in normal_list:
            f.write(f"vn {n[0]} {n[1]} {n[2]}\n")
            
        for i, face in enumerate(faces):
            f.write(f"f {face[0]}//{i+1} {face[1]}//{i+1} {face[2]}//{i+1}\n")
        
    # Write the corresponding MTL file
    self._write_mtl(mtl_filename, material_name)
</t>
<t tx="leo.20250516134148.6"></t>
<t tx="leo.20250516134148.60">    
def split_and_convert(self):
    """分割 STL 檔案並轉換為 OBJ 格式"""
    if self.is_binary:
        triangles, normals = self._read_binary_stl()
    else:
        triangles, normals = self._read_ascii_stl()
        
    components = self._split_by_connected_components(triangles, normals)
        
    output_dir = Path('split_parts')
    output_dir.mkdir(exist_ok=True)
        
    for i, component in enumerate(components):
        component_triangles = triangles[component]
        component_normals = normals[component]
            
        base_name = f"part_{i + 1}"
        stl_filename = output_dir / f"{base_name}.stl"
        obj_filename = output_dir / f"{base_name}.obj"
            
        #self._write_binary_stl(stl_filename, component_triangles, component_normals)
        self._write_obj(obj_filename, component_triangles, component_normals)
            
        print(f"已儲存零件 {i + 1} 到:")
        #print(f"  STL: {stl_filename}")
        print(f"  OBJ: {obj_filename}")
        print(f"  MTL: {obj_filename.with_suffix('.mtl')}")
        
    return len(components)
</t>
<t tx="leo.20250516134148.61"></t>
<t tx="leo.20250516134148.62">@path ./solvespace
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on: 2025-02-09 15:40:51 UTC
Author: mdecycu
Description: STL file converter that splits STL files into multiple OBJ files with MTL materials
"""

import struct
import numpy as np
from pathlib import Path

@others
# 直接轉換指定的 STL 檔案
try:
    # 指定要轉換的 STL 檔案名稱和縮放比例
    stl_file = "shooter_assembly.stl"
    scale = 0.01  # 縮放比例，可以根據需要調整

    # 創建轉換器實例並執行轉換
    converter = STLConverter(stl_file, scale=scale)
    num_parts = converter.split_and_convert()
    print(f"\n總共處理了 {num_parts} 個零件")
except Exception as e:
    print(f"錯誤: {e}")
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.63">class STLConverter:
    @others
</t>
<t tx="leo.20250516134148.64">def __init__(self, filename, scale=0.001):  # 新增 scale 參數，預設 0.001 將 mm 轉換為 m
    self.filename = filename
    self.scale = scale
    self.is_binary = self._check_if_binary()
</t>
<t tx="leo.20250516134148.65">        
def _check_if_binary(self):
    """檢查 STL 檔案是否為二進制格式"""
    with open(self.filename, 'rb') as f:
        header = f.read(5).decode('utf-8', errors='ignore')
        return not header.startswith('solid')
</t>
<t tx="leo.20250516134148.66">    
def _read_binary_stl(self):
    """讀取二進制 STL 檔案"""
    with open(self.filename, 'rb') as f:
        f.seek(80)
        triangle_count = struct.unpack('I', f.read(4))[0]
            
        triangles = []
        normals = []
            
        for _ in range(triangle_count):
            nx, ny, nz = struct.unpack('fff', f.read(12))
            normals.append([nx, ny, nz])
                
            triangle = []
            for _ in range(3):
                x, y, z = struct.unpack('fff', f.read(12))
                # 在讀取頂點時進行縮放
                triangle.append([x * self.scale, y * self.scale, z * self.scale])
            triangles.append(triangle)
                
            f.seek(2, 1)
                
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.67">    
def _read_ascii_stl(self):
    """讀取 ASCII STL 檔案"""
    triangles = []
    normals = []
    current_triangle = []
        
    with open(self.filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
                    
            parts = line.split()
            if not parts:
                continue
                
            if parts[0] == 'facet' and parts[1] == 'normal':
                normals.append([float(parts[2]), float(parts[3]), float(parts[4])])
            elif parts[0] == 'vertex':
                # 在讀取頂點時進行縮放
                current_triangle.append([
                    float(parts[1]) * self.scale,
                    float(parts[2]) * self.scale,
                    float(parts[3]) * self.scale
                ])
            elif parts[0] == 'endfacet':
                if current_triangle:
                    triangles.append(current_triangle)
                    current_triangle = []
        
    return np.array(triangles), np.array(normals)
</t>
<t tx="leo.20250516134148.68">    
def _split_by_connected_components(self, triangles, normals):
    """使用連通分量分割模型"""
    vertex_to_triangle = {}
    for i, triangle in enumerate(triangles):
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple in vertex_to_triangle:
                vertex_to_triangle[vertex_tuple].append(i)
            else:
                vertex_to_triangle[vertex_tuple] = [i]
        
    visited = set()
    components = []
        
    def dfs(triangle_idx):
        component = []
        stack = [triangle_idx]
            
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                component.append(current)
                    
                for vertex in triangles[current]:
                    vertex_tuple = tuple(vertex)
                    for neighbor in vertex_to_triangle[vertex_tuple]:
                        if neighbor not in visited:
                            stack.append(neighbor)
            
        return component
        
    for i in range(len(triangles)):
        if i not in visited:
            component = dfs(i)
            components.append(component)
        
    return components
</t>
<t tx="leo.20250516134148.69">    
def _write_binary_stl(self, filename, triangles, normals):
    """寫入二進制 STL 檔案"""
    with open(filename, 'wb') as f:
        f.write(b'\x00' * 80)
        f.write(struct.pack('I', len(triangles)))
            
        for triangle, normal in zip(triangles, normals):
            f.write(struct.pack('fff', *normal))
            for vertex in triangle:
                f.write(struct.pack('fff', *vertex))
            f.write(struct.pack('H', 0))
</t>
<t tx="leo.20250516134148.7">@path ./controllers/feed_ball
"""
利用 Webots 的監控模式在特定位置配合按鍵建立籃球物件
"""
# 匯入必要的模組
from controller import Supervisor, Keyboard  # Supervisor 用於控制模擬環境，Keyboard 用於監聽鍵盤輸入
import time  # 用於實現生成球後的延時
import random  # 用於生成隨機顏色

# 初始化 Supervisor 和 Keyboard 物件
supervisor = Supervisor()
keyboard = Keyboard()
keyboard.enable(int(supervisor.getBasicTimeStep()))  # 啟用鍵盤監聽，根據模擬時間步長設定

# 定義球的參數
sphere_radius = 0.1  # 球的半徑
sphere_position = (-0.62, 1.07, -0.25)  # 球的生成位置

# 定義一個函數，用於生成球的唯一 DEF 名稱
@others
# 主模擬迴圈
last_key_time = 0  # 記錄上次按下鍵的時間
debounce_time = 0.5  # 設定按鍵防抖時間為 0.5 秒

while supervisor.step(int(supervisor.getBasicTimeStep())) != -1:  # 模擬主迴圈
    key = keyboard.getKey()  # 獲取目前按下的鍵
    current_time = time.time()  # 獲取當前時間（實時）

    # 如果按下 'a' 且距離上次按鍵超過防抖時間
    if key == ord('A') and (current_time - last_key_time &gt;= debounce_time):
        create_sphere(supervisor, sphere_position)  # 在指定位置創建球
        last_key_time = current_time  # 更新上次按鍵的時間
@language python
@tabwidth -4
</t>
<t tx="leo.20250516134148.70">def _write_mtl(self, filename, material_name):
    """寫入 MTL 材質檔案"""
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"newmtl {material_name}\n")
        f.write("Ka 0.2 0.2 0.2\n")  # Ambient color
        f.write("Kd 0.8 0.8 0.8\n")  # Diffuse color
        f.write("Ks 0.5 0.5 0.5\n")  # Specular color
        f.write("Ns 50.0\n")         # Specular exponent
        f.write("d 1.0\n")           # Transparency (1.0 = opaque)
        f.write("illum 2\n")         # Illumination model
</t>
<t tx="leo.20250516134148.71">def _write_obj(self, filename, triangles, normals):
    """寫入 OBJ 檔案"""
    vertex_dict = {}
    vertex_list = []
    normal_list = []
    faces = []
        
    for triangle, normal in zip(triangles, normals):
        face_indices = []
            
        for vertex in triangle:
            vertex_tuple = tuple(vertex)
            if vertex_tuple not in vertex_dict:
                vertex_dict[vertex_tuple] = len(vertex_list) + 1
                vertex_list.append(vertex)
            face_indices.append(vertex_dict[vertex_tuple])
            
        normal_list.append(normal)
        faces.append(face_indices)
        
    # Generate material name from the obj filename
    material_name = filename.stem
    # Create MTL filename using Path
    mtl_filename = filename.with_suffix('.mtl')
        
    # Write OBJ file
    with open(filename, 'w', encoding='utf-8') as f:
        # Reference the MTL file
        f.write(f"mtllib {mtl_filename.name}\n")
        f.write(f"usemtl {material_name}\n\n")
            
        for v in vertex_list:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
            
        for n in normal_list:
            f.write(f"vn {n[0]} {n[1]} {n[2]}\n")
            
        for i, face in enumerate(faces):
            f.write(f"f {face[0]}//{i+1} {face[1]}//{i+1} {face[2]}//{i+1}\n")
        
    # Write the corresponding MTL file
    self._write_mtl(mtl_filename, material_name)
</t>
<t tx="leo.20250516134148.72">    
def split_and_convert(self):
    """分割 STL 檔案並轉換為 OBJ 格式"""
    if self.is_binary:
        triangles, normals = self._read_binary_stl()
    else:
        triangles, normals = self._read_ascii_stl()
        
    components = self._split_by_connected_components(triangles, normals)
        
    output_dir = Path('split_parts')
    output_dir.mkdir(exist_ok=True)
        
    for i, component in enumerate(components):
        component_triangles = triangles[component]
        component_normals = normals[component]
            
        base_name = f"part_{i + 1}"
        stl_filename = output_dir / f"{base_name}.stl"
        obj_filename = output_dir / f"{base_name}.obj"
            
        #self._write_binary_stl(stl_filename, component_triangles, component_normals)
        self._write_obj(obj_filename, component_triangles, component_normals)
            
        print(f"已儲存零件 {i + 1} 到:")
        #print(f"  STL: {stl_filename}")
        print(f"  OBJ: {obj_filename}")
        print(f"  MTL: {obj_filename.with_suffix('.mtl')}")
        
    return len(components)
</t>
<t tx="leo.20250516134148.8">def generate_valid_def_name(base_name="Sphere"):
    timestamp = int(supervisor.getTime() * 1000)  # 使用模擬時間生成唯一名稱
    return f"{base_name}_{timestamp}"
</t>
<t tx="leo.20250516134148.9"># 定義一個函數，用於生成隨機顏色
def generate_random_color():
    r = random.random()  # 生成隨機紅色分量 (0.0 - 1.0)
    g = random.random()  # 生成隨機綠色分量 (0.0 - 1.0)
    b = random.random()  # 生成隨機藍色分量 (0.0 - 1.0)
    return r, g, b
</t>
<t tx="leo.20250516135203.1">請詳細說明 ASCII STL 與 Binary STL 檔案格式, 並詳細解說如何透過 Python 讀取, 以及建立這兩種檔案格式的零件.

以下為 Markdown 格式

---

## 一、STL 檔案格式介紹

STL（STereoLithography）是一種描述 3D 幾何形狀的文件格式，常用於 3D 列印與 CAD 軟體。STL 文件描述由許多三角形面片組成的 3D 物件。主要有兩種格式：

### 1. ASCII STL 格式

- 純文字格式，內容容易閱讀與修改。
- 每個三角形由一個法向量與三個頂點定義。
- 格式範例：
    ```
    solid cube
      facet normal 0 0 1
        outer loop
          vertex 0 0 0
          vertex 1 0 0
          vertex 0 1 0
        endloop
      endfacet
      ...
    endsolid cube
    ```
- 每個三角形（facet）定義如下：
    ```
    facet normal nx ny nz
      outer loop
        vertex x1 y1 z1
        vertex x2 y2 z2
        vertex x3 y3 z3
      endloop
    endfacet
    ```

### 2. Binary STL 格式

- 二進位格式，體積小，讀取/寫入速度快。
- 檔案結構：
    1. 80 bytes 檔案標頭（header）：可為任意內容。
    2. 4 bytes（uint32）三角形數目。
    3. 對每個三角形（50 bytes）：
        - 12 bytes：法向量（float32 * 3）
        - 12 bytes：頂點 1（float32 * 3）
        - 12 bytes：頂點 2（float32 * 3）
        - 12 bytes：頂點 3（float32 * 3）
        - 2 bytes：屬性位元組（通常為 0）

---

## 二、用 Python 讀取 STL

### 1. 讀取 ASCII STL

可以直接用檔案讀取並解析字串：

```python
def read_ascii_stl(file_path):
    triangles = []
    with open(file_path, 'r') as f:
        lines = f.readlines()
    for i, line in enumerate(lines):
        if 'facet normal' in line:
            normal = list(map(float, line.strip().split()[2:]))
            v1 = list(map(float, lines[i+2].strip().split()[1:]))
            v2 = list(map(float, lines[i+3].strip().split()[1:]))
            v3 = list(map(float, lines[i+4].strip().split()[1:]))
            triangles.append({'normal': normal, 'vertices': [v1, v2, v3]})
    return triangles
```

### 2. 讀取 Binary STL

需用 struct 解析二進位檔：

```python
import struct

def read_binary_stl(file_path):
    triangles = []
    with open(file_path, 'rb') as f:
        header = f.read(80)
        num_triangles = struct.unpack('&lt;I', f.read(4))[0]
        for _ in range(num_triangles):
            data = f.read(50)
            normal = struct.unpack('&lt;fff', data[0:12])
            v1 = struct.unpack('&lt;fff', data[12:24])
            v2 = struct.unpack('&lt;fff', data[24:36])
            v3 = struct.unpack('&lt;fff', data[36:48])
            # attribute_byte_count = struct.unpack('&lt;H', data[48:50])[0]
            triangles.append({'normal': normal, 'vertices': [v1, v2, v3]})
    return triangles
```

---

## 三、用 Python 建立 STL 檔案

### 1. 建立 ASCII STL

```python
def write_ascii_stl(file_path, triangles, solid_name='model'):
    with open(file_path, 'w') as f:
        f.write(f"solid {solid_name}\n")
        for tri in triangles:
            n = tri['normal']
            v = tri['vertices']
            f.write(f"  facet normal {n[0]} {n[1]} {n[2]}\n")
            f.write("    outer loop\n")
            for vert in v:
                f.write(f"      vertex {vert[0]} {vert[1]} {vert[2]}\n")
            f.write("    endloop\n")
            f.write("  endfacet\n")
        f.write(f"endsolid {solid_name}\n")
```

### 2. 建立 Binary STL

```python
def write_binary_stl(file_path, triangles):
    with open(file_path, 'wb') as f:
        header = b'Python STL Writer' + b' ' * (80 - len('Python STL Writer'))
        f.write(header)
        f.write(struct.pack('&lt;I', len(triangles)))
        for tri in triangles:
            n = tri['normal']
            v = tri['vertices']
            data = struct.pack('&lt;fff', *n)
            data += struct.pack('&lt;fff', *v[0])
            data += struct.pack('&lt;fff', *v[1])
            data += struct.pack('&lt;fff', *v[2])
            data += struct.pack('&lt;H', 0)  # attribute byte count
            f.write(data)
```

---

## 四、簡單零件（三角形）範例

```python
# 定義一個三角面片
triangle = {
    'normal': (0.0, 0.0, 1.0),
    'vertices': [
        (0.0, 0.0, 0.0),
        (1.0, 0.0, 0.0),
        (0.0, 1.0, 0.0),
    ]
}

# 寫入 STL 檔
write_ascii_stl('triangle_ascii.stl', [triangle], solid_name='triangle')
write_binary_stl('triangle_binary.stl', [triangle])
```

---

## 五、建議

- 若需處理複雜模型或大量三角形，建議用 [numpy-stl](https://pypi.org/project/numpy-stl/) 或 [stl](https://pypi.org/project/stl/) 這類第三方模組，能大幅簡化操作。
- 以上程式碼皆可擴充為多三角形的模型。</t>
<t tx="leo.20250516135801.1">以下將詳細說明 **OBJ 3D 檔案格式**，並以 Python 實作如何讀取與建立 OBJ 3D 零件。

---

## 一、OBJ 檔案格式介紹

OBJ 是一種由 Wavefront Technologies 所開發的簡單 3D 檔案格式，廣泛用於 3D 列印、動畫與遊戲建模。  
其特點為：**純文字格式、易於閱讀、可描述頂點、法線、材質與多邊形面。**

### 1. 基本語法

- 每一行代表一種資料，開頭以字母標示：
    - `v x y z`：頂點座標
    - `vt u v`：貼圖座標（可選）
    - `vn nx ny nz`：法向量（可選）
    - `f v1 v2 v3 ...`：面（通常為三角形或四邊形）

#### 範例
```
# 這是一個簡單的三角形
v 0.0 0.0 0.0
v 1.0 0.0 0.0
v 0.0 1.0 0.0
f 1 2 3
```
- OBJ 中，頂點編號通常從 1 開始。

---

## 二、用 Python 讀取 OBJ 檔案

### 1. 基本 OBJ 讀取程式

```python
def read_obj(filename):
    vertices = []
    faces = []
    with open(filename, 'r') as f:
        for line in f:
            if line.startswith('v '):  # 頂點
                parts = line.strip().split()
                vertex = tuple(float(x) for x in parts[1:4])
                vertices.append(vertex)
            elif line.startswith('f '):  # 面
                parts = line.strip().split()
                face = [int(part.split('/')[0]) for part in parts[1:]]
                faces.append(face)
    return vertices, faces

# 用法
verts, faces = read_obj('model.obj')
print(verts)
print(faces)
```
- 這個範例僅讀取頂點與面，忽略紋理與法線資訊。

---

## 三、用 Python 建立（寫入）OBJ 檔案

### 1. 基本 OBJ 寫入程式

```python
def write_obj(filename, vertices, faces):
    with open(filename, 'w') as f:
        for v in vertices:
            f.write(f"v {v[0]} {v[1]} {v[2]}\n")
        for face in faces:
            f.write("f " + " ".join(str(idx) for idx in face) + "\n")

# 範例：建立一個三角形
vertices = [
    (0.0, 0.0, 0.0),
    (1.0, 0.0, 0.0),
    (0.0, 1.0, 0.0)
]
faces = [
    [1, 2, 3]
]

write_obj('triangle.obj', vertices, faces)
```
- OBJ 的面索引從 1 開始（不是 0）。

---

## 四、OBJ 標準內容說明

### 1. 頂點（v）
```
v 1.000000 2.000000 3.000000
```
### 2. 貼圖座標（vt）(可選)
```
vt 0.500 1
```
### 3. 法線（vn）(可選)
```
vn 0.0000 0.0000 1.0000
```
### 4. 面（f）
- 只用頂點編號：
    ```
    f 1 2 3
    ```
- 頂點/貼圖/法線組合：
    ```
    f 1/1/1 2/2/1 3/3/1
    ```
    - 格式：`f 頂點/貼圖/法線`

---

## 五、進階：讀寫包含法線與紋理的 OBJ

```python
def read_obj_advanced(filename):
    vertices, texcoords, normals, faces = [], [], [], []
    with open(filename, 'r') as f:
        for line in f:
            if line.startswith('v '):
                vertices.append(tuple(map(float, line.strip().split()[1:4])))
            elif line.startswith('vt '):
                texcoords.append(tuple(map(float, line.strip().split()[1:3])))
            elif line.startswith('vn '):
                normals.append(tuple(map(float, line.strip().split()[1:4])))
            elif line.startswith('f '):
                face = []
                for vert in line.strip().split()[1:]:
                    vals = vert.split('/')
                    v = int(vals[0])
                    vt = int(vals[1]) if len(vals) &gt; 1 and vals[1] else None
                    vn = int(vals[2]) if len(vals) &gt; 2 and vals[2] else None
                    face.append((v, vt, vn))
                faces.append(face)
    return vertices, texcoords, normals, faces
```

---

## 六、常用 Python 3D 模組
- [numpy-stl](https://pypi.org/project/numpy-stl/) （主要用於 STL）
- [trimesh](https://trimsh.org/)（支援 OBJ, STL, PLY，建議處理複雜模型）
- [PyWavefront](https://github.com/greenmoss/PyWavefront)（專門支援 OBJ）

---

## 七、總結

- OBJ 是純文字、易於手動讀寫的 3D 檔案格式。
- Python 可以用內建 open()/readline() 直接解析與建立 OBJ 檔案。
- 若需處理複雜模型，可用現成模組（如 trimesh、PyWavefront）。
</t>
</tnodes>
</leo_file>
