var tipuesearch = {"pages": [{'title': 'About', 'text': '課程倉儲與網頁: \n 倉儲:  https://github.com/mdecycu/cd2025 \n 網頁:  https://mde.tw/cd2025 \n 課程目標: \n 透過機電系統模擬與控制了解協同產品設計的特性與應用 \n 教學內容: \n 協同產品設計概論 \n 機電系統模擬 \n 協同分組專案 \n 協同分組報告 \n USB 隨身碟: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n 備註:\xa0 請更新上列 portable_wcm2025.7z 中的 wscite 為 5.5.5 版 ( wscite_5.5.5.7z , 解開壓縮檔案後取代 5.5.4 版的 wscite 目錄) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n 備註: 已知 Webots 2025a 有不少 bugs, 其中包括操作過程閃退以及無法使用 Transform 節點, 因此可以換為  Webots_2023b.7z  版. \n Blender4.2.7z \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n 學員作業網站樣板:  https://mde.tw/cd2025_hw   \n 學員作業範例:  https://mdecd2025.github.io/hw-scrum-1   \n 已知 w4 之前的學員作業倉儲版本, 無法在 IPv6 位址設定時正確運作, 各學員必須下載  cmsimde_w4.7z , 解開壓縮檔案後, 替換倉儲中的 cmsimde 目錄. \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n HW1 (5%): 建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n HW2 (5%): 建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Exam1 (10%): 建立 Webots 基本物件模擬場景 \n Exam2 (10%: 利用 CAD 零組件建立模擬場景 \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n 題目: Webots 動態投籃模擬系統的協同設計 \n \n \n 行事曆 \n 2a 上課時段: 每週五下午 13:20 - 17:10 (w2(228)、w7(春假)、w15(端午) 放假) \n 2b 上課時段: 每週二上午 08:10 - 12:00 \n  全頁檢視  \n', 'tags': '', 'url': 'About.html'}, {'title': 'Summary', 'text': '\n Edit cd2025.smm \n', 'tags': '', 'url': 'Summary.html'}, {'title': 'Product', 'text': 'Product Development Process (產品開發過程) \n \n (From  Fig. 1.2 ) \n Complex Product Assembly Process (複雜產品組立過程) \n \n (From  Fig. 1.4 ) \n Collaboration between Lifecycle Activities (生命週期活動間的協同) \n \n (From  Table 2.1 ) \n \n References: \n Geometric Constraint Solving and Application  (1998) ( local download ) \n The Semantics of Geometric Constraints \n Constraints for Conceptual and Collaborative Design \n Constraint Representation and Solving Methods \n Constraints for Freeform Surfaces \n CAD Systems Development  (1997) ( local download ) \n Core Blender Development  (2021) ( local download ) \n Collaborative Knowledge Management Through Product Lifecycle  (2023) ( local download ) \n', 'tags': '', 'url': 'Product.html'}, {'title': 'Control', 'text': '以下為網際虛擬控制相關參考資料: \n https://wokwi.com/ \n https://docs.wokwi.com/ \xa0 \n Wokwi, Arduino and Push Button \n Wokwi, Arduino and Potentiometer \n Wokwi, Arduino, Serial and Python \n \n ESP32 Web server \n https://github.com/wokwi/wokwigw/releases \xa0 \n https://docs.wokwi.com/guides/esp32-wifi#the-private-gateway \xa0 \n https://lcgamboa.github.io/picsimlab_docs/stable/OnlineSimulator.html \xa0 \n https://github.com/lcgamboa/picsimlab \xa0 \n HoRoSim, a Holistic Robot Simulator: Arduino Code, Electronic Circuits and Physics \xa0(2021) \n https://github.com/scrum-1/horosim \n', 'tags': '', 'url': 'Control.html'}, {'title': 'CPS', 'text': '以下為虛實整合系統 (Cyber-Physical System) 相關參考資料: \n Webots: \n https://www.cyberbotics.com \n https://github.com/cyberbotics/webots/discussions/2621 \n https://github.com/aidudezzz/deepbots  ( https://deepbots.readthedocs.io ) \n https://cad2.cycu.org/~yen/cad2023/content/PICSimLab.html \n Pinball \n pinball.7z \n https://pinball.flutter.dev  ( https://github.com/flutter/pinball ,  https://flutter.dev ) \n Foosball \n cad2024_foosball_with_ball_python_script.7z \n cad2024_foosball.7z \n CNN-based Game State Detection for a Foosball Table \n HoRoSim (使用 CoppeliaSim, 是否能夠轉進 Webots) \n HoRoSim, a Holistic Robot Simulator: Arduino Code, Electronic Circuits and Physics \n https://bitbucket.org/afaina/horosim/src/master/ \n', 'tags': '', 'url': 'CPS.html'}, {'title': 'AI', 'text': '以下為利用 AI 解題的相關參考資料: \n 利用 Gmail 帳號在  https://x.com/  註冊帳號後, 登入後直接點選左側的 Grok 進行對話. \n 另外可在個人手機或平板上安裝 X 與 Grok 3 App, 利用\xa0 X 帳號登入Grok 3 進行輔助學習. \n 使用範例: \n 提問 1 : 請用繁體中文詳細說明  https://cyberbotics.com/doc/guide/tutorial-1-your-first-simulation-in-webots  中的操作方法與重點 \n 隨後的對話可以直接輸入: \n 提問 2 :  https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment?tab-language=python \n 要求 AI 列出操作方法與重點. \n 提問 3 : 請幫我整理出這兩個 Tutorial 中所牽涉的英文單字與相關用法說明 \n 儘管 AI 對話過程可以快速協助列出相關 Tutorial 內容的重點與操作方法, 一旦完成操作後, 應該要再針對原文中的英文專有名詞或敘述句的用法進行研讀, 最終目的是 能夠在 AI 的協助下培養原文內容的快速閱讀與理解能力 . \n 除了 Grok 3, 也可透過  https://claude.ai 、 GPT  或  Gemini  等系統進行輔助學習. \n \n 如何因應 AI 時代的挑戰： \n 培養難以被AI取代的核心能力： \n \n 創意思考與問題解決能力 \n 跨領域整合的思維 \n 同理心與情感智商 \n 團隊合作與領導才能 \n 批判性思考與決策能力 \n \n 選擇未來導向的專業領域： \n \n AI 與機器學習相關技術 \n 數據分析與應用 \n 人機互動設計 \n 數位內容創作 \n 永續發展與環保科技 \n 心理諮商與生命教育 \n 創意產業與體驗設計 \n \n 建立終身學習習慣： \n \n 持續關注產業發展趨勢 \n 善用線上學習平台 \n 培養自主學習能力 \n 建立知識更新機制 \n 參與專業社群交流 \n \n 發展多元技能組合： \n \n 不要侷限在單一專業 \n 培養第二專長 \n 跨領域知識整合 \n 軟實力與硬實力並重 \n 培養數位工具運用能力 \n \n 保持開放與彈性思維： \n \n 擁抱新技術與改變 \n 適應力與抗壓性 \n 勇於嘗試新事物 \n 正向面對挑戰 \n 培養創業家精神 \n \n', 'tags': '', 'url': 'AI.html'}, {'title': 'Topics', 'text': 'Github Classroom : hw 為學員個人的作業倉儲, 2a 與 2b 則為各班的分組協同倉儲 \n \n cd2025 協同產品設計實習包括下列 4 個主題: \n Topic1: 可攜環境與 Github \n 主題 1 採用可攜環境可以讓參與協同的每一位成員使用相同版本的工具套件, 包括 Git, Python, Putty, VSCode, Sharex, wscite 以及 Wink. \n Github 則用來儲存個別學員與協同分組的產品設計內容, 因為倉儲中帶有內容管理系統, 每一位學員在進行各項階段性設計工程時, 都可以記錄詳細歷程, 也能利用個人及分組網頁展示內容, 其目的除了讓其他學員可以了解各階段提交的進度外, 也能透過互助合作的模式解決所面臨的問題. \n Topic2: 零組件繪圖 \n 主題 2 的零組件繪圖主要使用 Solvespace 與 Onshape , Solvespace 容量不到 10 MB 的參數式繪圖工具可減輕各學員配置或安裝大型的商業套件的負擔, 一旦各分組完成可以運作的產品系統模擬原始場景之後, 若需要讓最終的模擬場景更接近實體產品, 則可 Onshape 全雲端套件進行產品外型的零組件繪圖. \n Topic3: 建立模擬場景 \n 主題 3 採用的機電模擬場景工具為 Webots R2025a, 相較於 CoppeliaSim, Webots 採用 Apache 使用授權, 不限於在學校環境中使用. 結合  Deepbots  可用於機電系統的強化學習 (Reinforce Learning). \n https_server_py.7z  (利用 Python 伺服同目錄的 index.html) \n Topic4: 協同設計 \n 主題 4 為協同設計, 各組員可採同步或非同步模式或建立不同操除分支提交改版紀錄, 也可利用 Odoo PLM 模組建立產品開發生命週期間各階段組員的互動紀錄. \n', 'tags': '', 'url': 'Topics.html'}, {'title': 'Wink', 'text': '<!-- 假如檔案小於 5mb, 將 mp4 檔案放入 downloads 目錄後取出 -->\n<div class="winkVideoContainerClass"><video width="1008" height="630" autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/cmsimde/static" data-varname="your_video_unique_name" muted="true">\n<source src="./../downloads/your_video.mp4" type="video/mp4" /></video></div> \n 自行建立可攜 Python 的過程畫面: \n \n \n 使用 SSH 執行 git clone 與 git push 的過程畫面: \n \n \n 設定可攜套件 .gitconfig 的過程畫面: \n \n \n solvespace 零組件繪圖過程畫面: \n \n \n', 'tags': '', 'url': 'Wink.html'}, {'title': 'Fossil', 'text': 'Fossil SCM 的應用 \n https://fossil-scm.org/ \xa0 \n Github 與 Fossil SCM 結合應用範例: \n \n \n \n fossil init w4.fossil fossil ui w4.fossil ctrl c git clone https://github.com/mdecycu/cmsimde_site.git c cd c fossil open ./../w4.fossil --force fossil add . fossil commit -m "add c" cd .. fossil ui w4.fossil http://localhost:8081/doc/trunk/index.html \n \n trunk 為最新版本的代號, 若在 Fossil 系統中改版後, 可以將 trunk 換為版號, 直接看到該版的靜態網站內容. \n', 'tags': '', 'url': 'Fossil.html'}, {'title': 'Topic1', 'text': '可攜環境與 Github \n \n Edit topic1.smm \n', 'tags': '', 'url': 'Topic1.html'}, {'title': 'w1', 'text': '如何利用 C: 中舊的可攜程式環境建立 Portable_wcm2025? \n \n 下載  portable_python311.7z , 展開後是一套尚未安裝 pip 的 Python 3.11 可攜程式環境. \n 雙點擊 portable_python311 目錄中的 start_ipv6.bat 啟動可攜系統, 在 SciTE 中開啟 Y:\\ gen_python313.py , 以下拉式功能表 Tools - Go 執行, 便可在 Y:\\ 建立 Python313 目錄. \n 接著修改 start_ipv6.bat, 利用 Search - Replace, Find 欄位填上 Python311, Replace 欄位填上 Python313 後, 按下 Replace All, 便可將啟動檔中所有 Python311 設定改為 Python313, 另存修改後的檔案為 start_python313.bat. \n 接下來以 stop.bat 關閉 start_ipv6.bat 開啟的可攜系統, 改以心建立的 start_python313.bat 開啟可攜環境, 之後在命令列輸入 python, 確認目前的 Python 版本為 3.13.2 後, 利用 Ctrl + z 退出 Python 後, 利用 pip list 確認目前的 Python 3.13.2 系統尚未配置 pip 模組管理工具. \n 在命令列中, 以 python get-pip.py 安裝 pip 工具, 完成後, 以 pip list 確認 pip.exe 已經配置完成. \n 最後在命令列中, 以 pip install flask flask_cors bs4 lxml pelican markdown 安裝 cmsimde 網際內容管理系統啟動所需的 Python 模組後, 此可攜系統中的 Python 3.13.2 套件已經可以用來維護個人作業倉儲與分組倉儲. \n 之後利用新版的  SciTE ,  Portablegit ,  PUTTY ,  ShareX ,  Wink ,  Solvespace ,  Zoomit ,  ProcessExplorer  以及原有的 tmp 及 home_ipv6, 以新的 start_python313 啟動. \n \n 如何利用 Github 帳號與 Portable_wcm2025 建立 SSH 與認證用的 .reg 檔案? \n 確認 start 批次檔案中 GIT_SSH 環境變數已經指向 Putty \n 利用可攜程式中的 puttygen.exe 建立 OpenSSH 格式的公鑰(鎖頭)與 Putty 格式的私鑰(開門鑰匙) \n 利用 putty.exe 建立 SSH 遠端登入所需要的 session, 並將電腦組態登錄內容, 以 .reg 匯出存入隨身碟 \n 必須注意 .ppk 格式的私鑰存放位置是否能與可攜程式中所建立的 session 互相對應 \n 最後利用 session 設定, 以 git clone 將作業倉儲取下準備進行維護 \n 如何領取作業倉儲並利用 Portable_wcm2025 進行個人作業內容維護? \n 登入 Github 後, 利用 Github Classroom 作業連結取得個人倉儲 \n 在個人作業倉儲設定中的 Pages 以主分支作為作業網站的根目錄 \n 利用 cms 啟動編輯網站, 編輯結束後以 Convert 轉為靜態網頁 \n 利用 SStatic 啟近端的靜態網站檢視伺服器, 啟動後利用其右邊的按鈕檢視 \n 確認階段性編輯無誤後, 利用 acp 加上具體的提交訊息後採 SSH 協定推送 \n 分組組長如何利用 Github Classroom 協同作業連結建立團隊 (Team)? 學員如何 Join? \n cd2025 課程中的 Github Classroom 帳號為  https://github.com/mdecd2025/ \n 各學員的作業倉儲 (Repository) 位於:  https://github.com/orgs/mdecd2025/repositories \n 各班的協同倉儲 (Teams) 位於:  https://github.com/orgs/mdecd2025/teams \n 2b 各組的 Teams 名稱為 g 1 ,  g2  ..., 而 2a 各組的 Teams 名稱必須設定為 ag1, ag2 ... \n w1 任務 : \n 分組團隊 (Teams) 建立後, 請參考 說明 後, 將各班各學員與各團隊的倉儲與網站連結, 分別放入標題為 list (使用第一階標題) 的網頁中. \n 註冊 Onshape 教育帳號 \n \n \n', 'tags': '', 'url': 'w1.html'}, {'title': 'Portable', 'text': '以下將說明如何自行在 Windows 操作系統中建立可攜 Python 程式系統. \n 此作業的目的在展示如何利用既有的 Python 可攜系統建立各版本的 Python 可攜環境. \n 以下為操作步驟: \n \n 下載  portable_python311.7z , 展開後是一套尚未安裝 pip 的 Python 3.11 可攜程式環境. \n 雙點擊 portable_python311 目錄中的 start_ipv6.bat 啟動可攜系統, 在 SciTE 中開啟 Y:\\ gen_python313.py , 以下拉式功能表 Tools - Go 執行, 便可在 Y:\\ 建立 Python313 目錄. \n 接著修改 start_ipv6.bat, 利用 Search - Replace, Find 欄位填上 Python311, Replace 欄位填上 Python313 後, 按下 Replace All, 便可將啟動檔中所有 Python311 設定改為 Python313, 另存修改後的檔案為 start_python313.bat. \n 接下來以 stop.bat 關閉 start_ipv6.bat 開啟的可攜系統, 改以心建立的 start_python313.bat 開啟可攜環境, 之後在命令列輸入 python, 確認目前的 Python 版本為 3.13.2 後, 利用 Ctrl + z 退出 Python 後, 利用 pip list 確認目前的 Python 3.13.2 系統尚未配置 pip 模組管理工具. \n 在命令列中, 以 python get-pip.py 安裝 pip 工具, 完成後, 以 pip list 確認 pip.exe 已經配置完成. \n 最後在命令列中, 以 pip install flask flask_cors bs4 lxml pelican markdown 安裝 cmsimde 網際內容管理系統啟動所需的 Python 模組後, 此可攜系統中的 Python 3.13.2 套件已經可以用來維護個人作業倉儲與分組倉儲. \n 之後利用新版的  SciTE ,  Portablegit ,  PUTTY ,  ShareX ,  Wink ,  Solvespace ,  Zoomit ,  ProcessExplorer  以及原有的 tmp 及 home_ipv6, 以新的 start_python313 啟動. \n \n 在此有一點必須特別注意, SciTE 中有關使用 Pythonw.exe 解譯程式設定的檔案必須使用: \n if PLAT_WIN\n\tpython.command=pythonw.exe\nif PLAT_GTK\n\tpython.command=python3\nif PLAT_MAC\n\tpython.command=python \n 也就是使用當下所設定的 pythonw.exe 而非指定到特定舊版本的 pythonw.exe, 例如: Y:\\Python310\\pythonw.exe \n \n 自行製作可攜 Python, 以及配置 pip 的過程如下: \n \n \n', 'tags': '', 'url': 'Portable.html'}, {'title': 'repo', 'text': '此作業的目的在展示如何利用既有的 Python 可攜系統建立各版本的 Python 可攜環境. \n 以下為操作步驟: \n \n 下載  portable_python311.7z , 展開後是一套尚未安裝 pip 的 Python 3.11 可攜程式環境. \n 雙點擊 portable_python311 目錄中的 start_ipv6.bat 啟動可攜系統, 在 SciTE 中開啟 Y:\\ gen_python313.py , 以下拉式功能表 Tools - Go 執行, 便可在 Y:\\ 建立 Python313 目錄. \n 接著修改 start_ipv6.bat, 利用 Search - Replace, Find 欄位填上 Python311, Replace 欄位填上 Python313 後, 按下 Replace All, 便可將啟動檔中所有 Python311 設定改為 Python313, 另存修改後的檔案為 start_python313.bat. \n 接下來以 stop.bat 關閉 start_ipv6.bat 開啟的可攜系統, 改以心建立的 start_python313.bat 開啟可攜環境, 之後在命令列輸入 python, 確認目前的 Python 版本為 3.13.2 後, 利用 Ctrl + z 退出 Python 後, 利用 pip list 確認目前的 Python 3.13.2 系統尚未配置 pip 模組管理工具. \n 在命令列中, 以 python get-pip.py 安裝 pip 工具, 完成後, 以 pip list 確認 pip.exe 已經配置完成. \n 最後在命令列中, 以 pip install flask flask_cors bs4 lxml pelican markdown 安裝 cmsimde 網際內容管理系統啟動所需的 Python 模組後, 此可攜系統中的 Python 3.13.2 套件已經可以用來維護個人作業倉儲與分組倉儲. \n 之後利用新版的  SciTE ,  Portablegit ,  PUTTY ,  ShareX ,  Wink ,  Solvespace ,  Zoomit ,  ProcessExplorer  以及原有的 tmp 及 home_ipv6, 以新的 start_python313 啟動. \n \n 以下為操作影片: \n \n 說明如何取得個人作業倉儲並透過 TOKEN 修改內容之一: \n \n 說明如何取得個人作業倉儲並透過 TOKEN 修改內容之二: \n \n', 'tags': '', 'url': 'repo.html'}, {'title': 'SSH', 'text': '使用 SSH 協定執行作業倉儲的推送 \n SSH  是一種加密的網路傳輸協定, PuTTY 則是可用於 Windows 環境的 SSH 協定工具, 其中支援遠端登入 (putty.exe) 與檔案傳輸工具 (psftp.exe). \n 使用 PuTTY 所建立的公私鑰進行 Github push 認證的步驟: \n 第一步: \n 若希望在 Windows 環境透過 git 指令, 使用 PuTTY 設定的 session (一個代表連線伺服器主機、私鑰位置與是否使用代理主機等資訊的字串), 執行 push, 必須要在啟動可攜環境時, 設定 GIT_SSH 環境變數, 將此變數指向 PuTTY 套件中的 plink.exe 位置 (也就是 set GIT_SSH=%Disk%:\\putty\\plink.exe). \n 第二步: \n 指定利用 PuTTY 的 SSH session 執行 git push 後, 必須在 Windows 操作系統中選擇一個字串, 作為 SSH 連線 session 名稱, 由於此設定必須指向 SSH 協定加密用的私鑰所在目錄位置, 因此設定 session 之前, 必須利用 puttygen.txt 建立一對公私鑰, 其中的公鑰為 OpenSSH 格式, 必須送到使用者 Github 帳號設定區 (Settings) 的 SSH and GPG keys 中. \n 第三步: \n 利用 puttygen.exe 建立公私鑰的方法, 是在執行 puttygen.exe 之後, 以滑鼠按下 Generate 之後, 讓滑鼠在 puttgen.exe 視窗中 key 下方的空白區域隨意移動, puttygen.exe 會根據滑鼠移動的位置隨機建立 OpenSSH 格式的公鑰, 以及配對的 PuTTY 格式的 Private Key (副檔名為 .ppk) \n 第四步: \n 接下來, 將 OpenSSH 格式的 Public Key 內容複製到個人 Github 帳號設定區的 SSH and GPG keys 中, 並以 puttygen.exe 執行視窗右下方的 Save private key 按鈕, 將私鑰 (假設為 myprivatekey.ppk) 存至 Y:\\. \n 第五步: \n 接著啟動 PuTTY 中的 putty.exe, 在 Host Name (or IP Address) 欄位填入 github.com, 並確認 Connection Type 選用 SSH, 表示要透過 SSH 加密協定連線到 github.com. \n 第六步: \n 接著在 putty.exe 視窗下方的 Saved Sessions 填入一組字串, 此字串就是之後要遠端登入 github.com 設定 push 連線 URL 的 session 名稱, 在此假設選擇 "mysession" 作為 session 名稱, 使用者可以自行選擇具有代表性的字串, 例如: 學號或簡短的英文姓名縮寫. \n 第七步: \n 在 putty.exe 視窗中填入 github.com 與 "mysession" 名稱之後, 點擊 Save 之後, 此 session 設定就會被 Windows 操作系統存入該台電腦的 Registry 登錄檔案中的 HKEY_CURRENT_USER - SOFTWARE - SimonTatham 所在組態區. 此時可以在命令列中輸入 regedit 後進入登錄檔查看是否 mysession 已經存在. \n 第八步: \n 上列 "mysession" 設定完成且按下 Save 之後, 若再按下 Open, 採用 IPv4 網路連線的電腦應該已經可以透過 putty.exe 遠端連線至 github.com, 視窗中會出現 github.com 作為視窗標題, 且內容為 login as: 但一般使用者並沒有帳號可以直接透過 putty.exe 遠端登入到 github.com, 而只能在 session 設定完成後, 利用此 session 執行 git push. \n 第九步: \n 由於前面的 "mysession" 雖然已經存入 Windows 操作系統的登錄檔, 但並沒有設定 private key 的位置, 因此接下來要再開啟 putty.exe, load 進此一 session, 然後在此 session 設定左方的 Category: 下方的 Connection - SSH - Auth - Credentials 設定中的 Private key file for authentication: 區, 利用 Browse 選擇位於 Y:\\ 的 myprivatekey.ppk 檔案. 選擇檔案完成後, 必須再回到 Catetory: 下方的 Session 區, 以右方的 Save 將附加私鑰位置設定的 session 存檔. 此時 Windows 登錄檔中的 "mysession" 除了代表要使用 SSH 連線到 github.com 之外, 還附帶指定了 myprivatekey.ppk 在 Y:\\ 的位置. \n 第十步: \n 若上述設定是在電腦輔助設計室中的電腦進行, 必須利用命令列 regedit 指令, 進入 HKEY_CURRENT_USER - SOFTWARE - SimonTatham 位置, 利用滑鼠右鍵將此登錄設定檔案"匯出" 存入可攜程式 start_ipv6.bat 所在目錄, 此處假設命名為 mysession.reg, 使用者可以自行對 .reg 命名. \n 第十一步: \n 由於上列的 myprivatekey.ppk 存於可攜程式中的 Y:\\, 因此當使用者利用 start_ipv6.bat 啟動可攜程式後, 就可以利用滑鼠雙點擊位於同目錄的 mysession.reg, 上述的 "mysession" 設定就會存入 Windows 操作系統的登錄檔中. \n 使用 PuTTY session 設定倉儲 .git/config 中的 URL \n 假設上列 "mysession" 對應中的 OpenSSH 格式公鑰是送到 Github 帳號為 scrum-1 學員的 SSH and GPG key 區域, 則 scrum-1 學員在啟動可攜系統後, 已經雙點擊 mysession.reg, 將前述 putty.exe 設定的 session 組態登錄設定回存至 Windows 操作系統中, 則 scrum-1 學員就可以將其近端作業倉儲中的 mysession 用於倉儲 .git/config 檔案的下方設定: \n [remote "origin"]\n    url = git@mysession:mdecd2025/hw-scrum-1.git\n    fetch = +refs/heads/:refs/remotes/origin/ \n 其中的 [remote "origin"] 表示當使用 git 指令中針對此倉儲 "origin" 是一個與遠端倉儲對應的字串代號, 代表其下兩項設定. url 代表此 "origin" 的倉儲連線網址, 而連線至此倉儲的協定是採遠端登入 (使用 Github 支援的 SSH 遠端登入協定), 且此遠端登入的帳號為 "git", 這是所有要使用 SSH 執行 git push 的用戶共同使用的登入帳號. \n url 設定中 "@" 之後的 "mysession" 就是宣告要使用此電腦登錄檔中所設定的 session 名稱 (代表要連線到 github.com, 且帶的 myprivatekey.ppk, 準備在登入流程中與 github.com 中 mdewcm2025 帳號下的 hw-scrum-1 倉儲擁有者 (或帶有 repo 管理權限的帳號) 所登錄的 public keys 進行認證比對, 一旦通過認證, git push 指令就可以成功將改版資料推送到指定的倉儲區域. \n', 'tags': '', 'url': 'SSH.html'}, {'title': 'list', 'text': '以下過程將各班學員的倉儲與網站連結列出: \n 讀出 list 倉儲資料 ( 執行結果 ): \n # 從  Brython 程式庫中的 browser 導入 html, 可用來輸出超文件內容\nfrom browser import html\n# 建立 url 變數與網站中 2b 學員的學號與帳號資料 URL 網誌字串對應\nurl = "https://mde.tw/list/2b.txt"\n# 利用 open() 物件中的 readlines() 方法, 取出網站中的資料並逐行放入數列中, 因此 data 的資料型別為數列\ndata = open(url).readlines()\n# 進行資料查驗時, 印出 data 數列內容\n#print(data)\n# 因為學員資料中的第一列為標題, 因此有效資料從索引值 1 開始\nall_stud = data[1:]\n# 利用 len() 函式查驗 all_stud 數列有幾筆資料, 因為要與前後的字串併接, 因此利用 str() 將整數轉為字串\nprint("總共有 " + str(len(all_stud)) + "名學員") \n 建立 anchor 與 break 標註 ( 執行結果 ): \n # 從  Brython 程式庫中的 browser 導入 html, 可用來輸出超文件內容\n# 而所導入的 document 可以指向網頁中的特定 id 內容\nfrom browser import html, document\n# 建立 url 變數與網站中 2b 學員的學號與帳號資料 URL 網誌字串對應\nurl = "https://mde.tw/list/2b.txt"\n# 利用 open() 物件中的 readlines() 方法, 取出網站中的資料並逐行放入數列中, 因此 data 的資料型別為數列\ndata = open(url).readlines()\n# 進行資料查驗時, 印出 data 數列內容\n#print(data)\n# 因為學員資料中的第一列為標題, 因此有效資料從索引值 1 開始\nall_stud = data[1:]\n# 利用 len() 函式查驗 all_stud 數列有幾筆資料, 因為要與前後的字串併接, 因此利用 str() 將整數轉為字串\nprint("總共有 " + str(len(all_stud)) + "名學員")\n# \n# 利用 document[] 取得 id 為 "brython_div1" 的位置, 然後與 brython_div1 變數對應\nbrython_div1 = document["brython_div1"]\n# 利用 Brython 的 "<=" 特殊符號, 將右值帶有字串與超文件內容物件插入 brython_div1 變數所指定的位置\n# 其中利用 html.A 建立 anchor 標註物件, 第一個變數為 anchor 字串, 第二個變數則為 hyper text reference\nbrython_div1 <= "1. " + html.A("scrum-1", href="https://mdecd2025.github.io/hw-scrum-1")\n# 利用 html.BR() 插入 break 標註\nbrython_div1 <= html.BR()\nbrython_div1 <= "2. " + html.A("github.com", href="https://github.com") \n 列出 2a 學員作業網站與倉儲連結 \n 列出 2b 學員作業網站與倉儲連結 \n 列出 2a 分組網站與倉儲連結 \n 列出 2b 分組網站與倉儲連結 \n \n 請列出各班目前尚未納入分組的學員名單 \n 透過下列程式: \n import os\n# pip install pygithub\nfrom github import Github\n# the following is under IPv6\n# Replace these variables with your own details\nGITHUB_TOKEN = \'your_token\'\nORG_NAME = \'mdecd2025\'\nPROXY = \'http://p4.cycu.org:3128\'\n\ndef get_all_team_members_starting_with_a(org_name, token, proxy):\n    # Set proxy environment variables\n    os.environ[\'http_proxy\'] = proxy\n    os.environ[\'https_proxy\'] = proxy\n\n    # Initialize Github object\n    g = Github(token)\n    all_members = []\n\n    try:\n        # Get organization\n        org = g.get_organization(org_name)\n        \n        # Get all teams\n        teams = org.get_teams()\n        \n        for team in teams:\n            if team.name.lower().startswith(\'g\'):\n                print(f"Processing team: {team.name}")\n                # List members\n                members = team.get_members()\n                for member in members:\n                    all_members.append(member.login)\n                    print(f"Login: {member.login}, ID: {member.id}, URL: {member.html_url}")\n                    \n        print("\\nAll members:", all_members)\n    except Exception as e:\n        print(f"An error occurred: {e}")\n\nif __name__ == "__main__":\n    get_all_team_members_starting_with_a(ORG_NAME, GITHUB_TOKEN, PROXY) \n 已知各班已經參與分組的學員 Github 帳號分別如下: \n a_all_members = [\'41223154\', \'41271125\', \'41271158\', \'41271146\', \'41271131\', \'CYG41223103\', \'41223102\', \'41023128\', \'41023137\', \'41223137\', \'41223157\', \'41223156\', \'otakuyoyo\', \'41223141\', \'41223113\', \'kim41223114\', \'joeisme1208\', \'41223116\', \'41223144\', \'41223140\', \'41223143\', \'41223138\', \'41223134\', \'41223136\', \'zhe41223118\', \'Spirit0224\', \'yuhao-08\', \'41223158\', \'Ren911308\', \'41223150\', \'Manto8\', \'CYA41223106\', \'yan21ed\', \'Lin41223107\', \'41223133\', \'hong41223129\', \'41223110\', \'41223147\', \'Linjiahong41223125\', \'CHN41223132\', \'Yu-Fang-Hong\', \'41023111\', \'yckaooooo\', \'kolas911205\', \'41023105\', \'40932134\', \'41223104\', \'yan41223101\', \'41223105\', \'41223153\', \'41223120\', \'41223152\', \'G8People\', \'WSE41223112\', \'41223146\', \'41223119\']\nb_all_members = [\'41223251\', \'41223211\', \'41223245\', \'41223243\', \'jjjay41223212\', \'leeshaowei0716\', \'41223234\', \'41223209\', \'41223205\', \'41223201\', \'41223202\', \'41223208-hw\', \'41223216\', \'41223217\', \'41223248\', \'emma0312\', \'41223242\', \'41223203\', \'41223144\', \'41223235\', \'RAY41223215\', \'hyy41223228\', \'41223227\', \'41223206\', \'41223226-0\', \'Cloud41223237\', \'Yujenchuang\', \'41223225\', \'ljg41223220\', \'supowen\', \'jacky93111\', \'41223246\', \'Liu41223244\', \'41223236\', \'41223219\', \'41271237\', \'41223249\', \'41223229\', \'41223224\', \'41223222\', \'41223231\', \'linryan23\', \'41023114\', \'41223230\', \'timluo123\', \'CYC41223247\', \'41223218\', \'ych0227\', \'41023215\', \'41023216\', \'41023213\', \'41071203\', \'41071204\', \'41071202\', \'c-ching\', \'YUN4\', \'tseYU000\', \'snowfall-killer\', \'junpig10\'] \n 請接著列出目前各班尚未納組的學員學號. \n 首先看能否從 list\\2a.txt  讀出學員的學號與 github 帳號 : \n # 建立 url 變數與網站中 2a 學員的學號與帳號資料 URL 網誌字串對應\nurl = "https://mde.tw/list/2a.txt"\n# 利用 open() 物件中的 readlines() 方法, 取出網站中的資料並逐行放入數列中, 因此 data 的資料型別為數列\ndata = open(url).readlines()\n# 進行資料查驗時, 印出 data 數列內容\n#print(data)\n# 因為學員資料中的第一列為標題, 因此有效資料從索引值 1 開始\nall_stud = data[1:]\n# 確定已經取得 2a.txt 中的學號與 github 帳號資料\n#print(all_stud)\n# 利用 for 迴圈逐一列出各學員的單行資料\n# 已知各行資料是以 \\n 跳行, 可以設法先刪除每一筆資料最後的跳行符號\nfor i in all_stud:\n    #print(i)\n    drop_n = i.rstrip("\\n")\n    # 確定每一行最後的跳行符號已經移除\n    #print(drop_n, end="")\n    # 設法利用學號與帳號間的 "\\t" 將資料隔開\n    stud = drop_n.split("\\t")\n    #print(stud)\n    stud_num = stud[0]\n    stud_github = stud[1]\n    print("學號為 ", stud_num, " 的學員, 其 Github 帳號為 ", stud[1]) \n 只要在迴圈中加入下列判斷式: \n #print("學號為 ", stud_num, " 的學員, 其 Github 帳號為 ", stud[1])\nif stud_github not in a_all_members:\n    print(stud_num) \n 即可取得下列尚未納組的學員學號: \n 2a : \n 41023220 41223111 41223119 41223124 41223148 \n 2b : \n 40923137 41023237 41223210 41223214 41223223 41223232 41223233 41223239 41223245 41271217 41271236 \n \n w4:\xa0 w4_2b_grouping.txt \n \n', 'tags': '', 'url': 'list.html'}, {'title': 'IPv6', 'text': '已知 w4 之前的學員作業倉儲版本, 無法在 IPv6 位址設定時正確運作, 各學員必須下載  cmsimde_w4.7z , 解開壓縮檔案後, 替換倉儲中的 cmsimde 目錄. \n IPv6 設定: \n 2a 各學員固定 IPv6 分配: 2001:288:6004:17:fff1:cd25:0000:a001 2b 各學員固定 IPv6 分配: 2001:288:6004:17:fff1:cd25:0000:b001 gateway: 2001:288:6004:17::254 dns server:  2001:288:6004:17::3 2001:b000:168::1 \n 2a 以\xa0 w4_2a_index.txt \xa0中的序號為準, 例如: 序號為 1 的學員其固定 IPv6 位址為: \n 2001:288:6004:17:fff1:cd25:0000:a001 \n 若序號為 60 其 IPv6 位址為\xa02001:288:6004:17:fff1:cd25:0000:a060 \n 2b 以\xa0 w4_2b_index.txt \xa0中的序號為準, 例如: 序號為 1 的學員其固定 IPv6 位址為: \n 2001:288:6004:17:fff1:cd25:0000:b001 \n 若序號為 66 其 IPv6 位址為\xa02001:288:6004:17:fff1:cd25:0000:b066 \n 註: 利用 Brython  產生  DNS 伺服器所需的設定. \n 完成 dns 設定之後: \n 2a 序號為 1 的學員其伺服器主機符號名稱為 a1.mde.nfu.edu.tw, 序號 50 則對應 a50. \n 2b 序號為 1 的學員其伺服器主機符號名稱為 b1.mde.nfu.edu.tw, 序號 50 則對應 b50. \n \n 各組員將電腦設為所份配的固定 IPv6 後, 可以利用 python -m http.server, 在作業倉儲中啟動 port 8000 的 http 靜態網頁伺服器, 以下為各班的近端學員靜態網站連結: \n 列出 2a 分組網站與倉儲連結 \n 列出 2b 分組網站與倉儲連結 \n 2a IPv6 port 8000 連線列表 \n 2b IPv6 port 8000 連線列表 \xa0( 列出無法連線學員 ) \n \n 以下為與 AI 系統的對話: \n 請用 Brython 寫出在 id="brython_div1" 嵌入 html 連結的程式. 希望各連結能透過 http 協定連結到班上有 66 位學員的靜態網頁. 其中各學員的固定 IPv6 分別為 2001:288:6004:17:fff1:cd25:0000:b001 到 2001:288:6004:17:fff1:cd25:0000:b066, 且使用 port 8000 進行連結. 請寫出此一 Brython 程式. \n 取得下列程式:  透過 2b 學員序號列出其 IPv6 靜態網站 \n 完成上述以序號標示後, 透過下列詢問可以取得以學號作為標示的各學員近端靜態網站連結. \n 任務一: 請用 Brython 寫出在 id="brython_div1" 嵌入 html 連結的程式. 希望各連結能透過 http 協定連結到班上有 66 位學員的靜態網頁. 其中各學員的固定 IPv6 分別為 2001:288:6004:17:fff1:cd25:0000:b001 到 2001:288:6004:17:fff1:cd25:0000:b066, 且使用 port 8000 進行連結. 請寫出此一 Brython 程式. \n 任務二: 若各學員序號取自 https://mde.tw/cd2025/downloads/w4_2b_index.txt, 且此一資料以空白隔開序號加"." 及學號, 能否修改成以學員的學號作為 html 的標示. \n 任務三: 完成各學員的 html 連結後, 請再用 Brython 程式設法進入每一位學員的網站查驗, 是否可以讀取到該連結 content 目錄中的 About.html, 若可以則 pass, 若無法連結則列出無法完成連結的學員學號. \n 請分別列出上述三個任務的程式碼. \n', 'tags': '', 'url': 'IPv6.html'}, {'title': 'Topic2', 'text': '零組件繪圖 \n \n Edit topic2.smm \n', 'tags': '', 'url': 'Topic2.html'}, {'title': 'Compile', 'text': '以下要說明如何利用可攜程式套件編譯 Solvepace: \n 下載  cmake_and_msys64.7z , 將 cmake-3.21.0-windows-x86_64、msys64 與 libwinpthread-1.dll 等資料放入  portable_wcm2025.7z  解開壓縮後的 data 目錄中, 啟動可攜程式檔案就可以使用  MSYS2  編譯 Solvespace 3.1 版的原始碼. 取得的 solvespace.exe 只要與 libwinpthread-1.dll 處於同一個目錄, 就可以執行編譯完成的 solvespace.exe 執行參數化零組件的繪圖. \n 備註:\xa0 請更新上列 portable_wcm2025.7z 中的 wscite 為 5.5.5 版 ( wscite_5.5.5.7z , 解開壓縮檔案後取代 5.5.4 版的 wscite 目錄) \n 編譯 Solvespace 的詳細步驟如下: \n 配置好  cmake_and_msys64.7z  後, 啟動可攜程式 \n 在命令列中 cd tmp, 然後利用 git clone --recurse-submodules  https://github.com/solvespace/solvespace.git  取下 solvespace 的原始碼 \n cd solvespace 後, 利用 git checkout v3.1 將版本切換到 v3.1 的原始碼內容 \n 接下來則必須修改\xa0solvespace\\extlib\\angle\\src\\libANGLE\\HandleAllocator.cpp 加入標頭檔案: \n #include <limits> \n 接著就可以進行程式碼的編譯與連結: \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release \n mingw32-make \n 完成編譯後, solvespace.exe 即位於 build\\bin 目錄中, 執行時則需要\xa0libwinpthread-1.dll 動態連結程式庫. \n 進行上述流程編譯的原始碼\xa0 solvespace_v3.1_src.7z , 以及編譯完成的  solvespace_v3.1_msys2.7z . \n 註:  portable_wcm2025.7z  中所配置的 solvespace.exe 是採用 Visual Studio C++ 編譯, 檔案只有約 7MB, 因為其執行時所需的動態連結程式庫已經配置在 Windows 操作系統中, 因此檔案較小, 而採上述流程, 使用  MSYS2  可攜方式編譯所得到的 solvespace.exe, 檔案約 15MB, 還需要 62KB 的 libwinpthread-1.dll 才能執行, 這是因為採  MSYS2  編譯的 solvespace.exe 必須自帶執行所需的程式庫, 因此檔案較大. \n \n', 'tags': '', 'url': 'Compile.html'}, {'title': 'Onshape', 'text': '註冊 Onshape 教育帳號 , 登入後畫面如下: \n \n Onshape 入門指南 \n Learn Onshape \n Tutorial 1: Creating Object (建立物件) \n \n Tutorial 2: Adding Features (建立特徵) \n \n Tutorial 3: Misc tidbits (雜項花絮) \n \n Tutorial 4: Views and Orientation (視圖與方位) \n \n Tutorial 5: Documents (文件) \n \n Units and Decimal: 單位與小數點位數 \n \n Export to STL: 導出 STL 格式檔案 \n \n', 'tags': '', 'url': 'Onshape.html'}, {'title': 'Topic3', 'text': '建立模擬場景 \n \n Edit topic3.smm \n 平面四連桿機構參考資料: \n fourbar acceleration analysis  ( video ) \n fourbar mechanism \n fourbar chain catapult \n RRRP fourbar linkage \n Research papers using Webots \n', 'tags': '', 'url': 'Topic3.html'}, {'title': 'Fourbar2', 'text': '平面四連桿機構運動分析 \n Reference:  1 ,  2 ,  3 \n cd2025_box_fourbar_w5.7z \n fourbar_box_w5.7z \n basket_ball_shooter.7z \n basket_ball_shooter.7z \n 請注意, 所有 world 的存檔必須要將模擬時間轉為 0 , 否則所存的變數狀態將為該時間的模擬結果. \n Tutorial 1  重點摘要: \n 將\xa0 Webots_2025a_web.7z \xa0解開壓縮後放入可攜套件 ( portable_wcm2025.7z ) 的 data 目錄中. \n 因為 start.bat 中已經宣告 Python 所在位置, 並將執行 webotsw.exe 所在的目錄放入 Windows 的命令搜尋路徑變數中 (path). \n REM for Webots\nset PYTHON_PATH=%Disk%:\\Python313\n\nREM for webots\nset  path_webots=%Disk%:\\Webots_2025a\\msys64\\mingw64\\bin;%Disk%:\\Webots_2025a\\msys64\\usr\\bin \n 當起始一個 Webots project, 需要至少建立 worlds、controllers、protos 等三個目錄, 而且 Robot 的 控制器程式必須放入 controllers 目錄, 且控制程式檔名必須與子目錄相同 . \n Tutorial 2  重點摘要: \n \n 根據上圖, 在  Webots 建立剛體物件, 必須使用 Solid 節點, 並從節點中的 children 建立 Shape 後宣告其 geometry 外形用於系統的運動方程式, 而其碰撞檢測的外形依據, 則從 Solid 節點的 boundingObject 中的 geometry 進行確認 . \n 另外可從 View - Optional Rendering - Show coordinate system 選項, 要求系統列出目前視圖所依據的座標系統. \n 當在 base 物件建立旋轉軸時, HingeJoint 物件的位階必須與 base 相同, 而且 link1 的 solid 物件必須接在 HingeJoint 的 endPoint 節點上, 且因為 link1 的最後位置並非位於其旋轉中心, 因此在建立 link1 solid 物件下的 shape 之前必須先使用 pose 物件, 以便在 solid 的 parent 座標系統之下, 建立一個屬於 shape 的局部座標轉換系統. \n 另外 HingeJoint 的旋轉中心位置是由 jointParameters 物件下的 anchor 欄位決定, 而其旋轉軸則由 axis 欄位決定. \n 由於 link1 最後需要透過碰撞檢測來與籃球互動, 因此除了 dynamic simulation 之外, 還需要設定 boundingObject, 才能界定 link1 的碰撞幾何外形, 但由於前面的 link1 並非在其 parent 座標系統的物件中心旋轉, 而是透過其局部座標轉換 (利用 pose 物件達成), 往局部 x 方向移動 0.2m, 因此 boundingObject 在引用其 shape 時, 也必須透過 pose 轉換到 link1 最終所在位置. \n 上列流程所完成的 Webots 專案檔:\xa0 w6_demo_project.7z \xa0(joint on link1) \n w6_joint_on_base_project.7z \xa0(joint on base) \n \n', 'tags': '', 'url': 'Fourbar2.html'}, {'title': 'boomer', 'text': 'w5_boomer.7z \n', 'tags': '', 'url': 'boomer.html'}, {'title': 'Topic4', 'text': '協同設計 \n \n Edit topic4.smm \n', 'tags': '', 'url': 'Topic4.html'}, {'title': 'Tutorial', 'text': 'Webots R2025a 執行環境硬體需求: 2 GHz 4 核心以上 CPU, NVIDIA 或 AMD 支援 OpenGL 3.3 版, 帶有 512 MB 記憶體以上獨立顯示卡 操作系統: \n Windows 10 或 11 64 位元操作系統 \n Ubuntu 24.04 以上版本 \n macOS 12 以上版本操作系統 \n 使用介面: \n Webots 可以透過 Tools - Preferences - Language 中選擇使用 English 或簡體中文介面 (目前無繁體中文介面, 介面語系翻譯請參考  translations 頁面 說明), 在此強烈建議使用 English 界面即可. \n Webots 版本差異: \n 每一版本都有些微差異, cd2025 將使用  R2025a . \n R2025a changelog \n \n Webots 原始碼使用授權: 採  Apache 2.0 license agreement . Apache 2.0 是一種開放且對企業友善的授權條款, 允許任何人免費使用、修改和分享軟體的原始程式碼, 包括商業用途使用. \n 自行編譯 Webots 請參考  building Webots 頁面 說明. \n Webots 套件中的大部分範例模擬檔案都使用 Apache 2.0 許可釋出, 但有部分機器人和物件模型（proto 檔案）則是根據  Webots 資產的開放原始碼許可協議 發佈, 另外有些範例則是由用戶根據不同的開源許可證所提供, 這些檔案都會明確標示其許可證內容. \n \n Webots 介紹: (查英英字典:  https://www.merriam-webster.com/dictionary/ ) \n What is Webots? \n What can I do with Webots? \n Webots simulation \n What is a world? \n What is a controller? \n What is a supervisor controller? \n Webots Crash Course  (速成班教學影片) \n \n 第一個 Webots 導引:  https://cyberbotics.com/doc/guide/tutorial-1-your-first-simulation-in-webots \n 登入 Github, 在  https://github.com/copilot  的協助下執行此一教學練習. \n 導引目的: You will create your first simulation containing a simple environment: an arena with floor and walls, a few boxes, an e-puck robot and a controller program that will make the robot move. \n 建立一個簡單的模擬環境, 意即一個競技場中, 包括一個帶有地板、圍牆、幾個盒子、一個 e-puck 機器人, 以及能讓機器人移動的控制程式. \n \n 開啟 Webots 前, 請下載  Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB). \n 有關 Webots 在 Windows 操作系統啟動, 請參考 說明 . 有關 Web streaming 也請參考 說明 . \n Webots 的可執行檔案位於 Y:\\Webots_2025a\\msys64\\mingw64\\bin\\Webotsw.exe, 當與  python_2025_lite.7z  配置時, 若希望在不上網的情況下執行官方範例, 則必須再預先下載  https://github.com/cyberbotics/webots/releases/tag/R2025a  中的  assets-2025a.zip , 存入 Y:\\home_ipv6\\AppData\\Local\\Cyberbotics\\Webots\\cache\\assets 目錄, 否則啟動官方範例時, 必須從官方網站下載各範例中所導入的原型節點資料. \n 若 Webotsw.exe 並非是在可攜程式的環境中啟動, 則 Webots 啟動後所下載的原型節點資料, 將會存入操作系統中的 C:\\Users\\%USERNAME%\\AppData\\Local\\Cyberbotics\\Webots\\cache\\assets 目錄中. \n 在可攜程式環境中啟動 Webots 的設定: \n start_ipv6.bat 中納入: \n REM for webots set\xa0 path_webots=%Disk%:\\Webots_2025a\\msys64\\mingw64\\bin;%Disk%:\\Webots_2025a\\msys64\\usr\\bin \n 並將 %path_webots% 放入 PATH 環境變數設定中. \n 若希望在執行 start_ipv6.bat 時開啟 Webots, 可以在啟動可攜程式的批次檔案中加入 start webotsw.exe \n 在可攜程式環境中 (USB 固態硬碟、一般隨身碟、筆電或個人電腦) 啟動 Webots 後, 開始建立模擬世界(即場景), 而在 Webots 中所謂場景: \n A  World  is a file containing information like where the objects are, what they look like, how they interact with each other, what is the color of the sky, and the definitions of gravity, friction, masses of the objects, etc. It defines the initial state of a simulation. The different objects are called  Nodes  and are organized hierarchically in a  Scene Tree . Therefore, a node may contain sub-nodes. A world is stored in a file having the  .wbt  extension. The file format is derived from the\xa0 VRML97  language, and is human readable. The world files must be stored directly in a directory called  worlds . \n Webots 場景中包含以下定義: \n \n 物件所在位置 \n 物件的外形 \n 物件如何互動 \n 天空的顏色 \n 地心引力的定義 \n 摩擦力 \n 物件的質量 \n 模擬的起始條件 \n 其他有關模擬的設定等 \n \n 場景中的物件稱為節點, 各節點配置於場景樹中, 各節點可以再包含子節點, 場景的檔案格式源自 VRML97 程式語法 ( VRML Primer and Tutorial ), 場景的檔案副檔名為 .wbt, 且一定要存入名稱為 worlds 的目錄中. \n Webots 模擬選單功能說明:  https://cyberbotics.com/doc/guide/the-user-interface#simulation-menu  其中著色選單可以關閉場景中的畫面, 主要配合基因演算、視覺辨識或機器學習流程中的快速模擬流程. \n', 'tags': '', 'url': 'Tutorial.html'}, {'title': 'Fourbar', 'text': 'onelink \n onelink_webots.7z  (直接採 Shape 建模) \n fourbar_box_w8.7z \xa0(將 joint4 接在 link3 末端, 然後  solidReference  參照到內定的 <static environment>, 表示將 link3 末端的 joint4 直接固定在 base 上 (固定點) \n onelink_slvs.7z  (利用 Solvespace 繪製組立檔案, 轉為 STL 後, 再分割為 STL 零件與 OBJ 零件後, 將 OBJ 零件 import 進 Blender 確認零件名稱, 各 OBJ 零件分別利用 Solid 與 CadShape 節點建立從屬關係, 最後加入 hinge 旋轉軸與 Python 控制程式, 讓單一機械臂以 30deg/s 速度轉動) \n onelink_w_hinge.wbt 直接在場景樹狀結構中定義 Solid (可用於較簡單的零組件系統) \n onelink_w_hinge2.wbt 則將各零件以 PROTO 定義為原型節點, 之後在場景中導入後引用 (適合較複雜的零組件系統) \n fourbar1 \n 以下利用 box 建立 Webots 平面四連桿場景: \n 層次結構： \n Robot → BASE \n Robot → JOINT1 → LINK1 → JOINT2 → LINK2 → JOINT3 → LINK3 \n Robot → JOINT4 (closed chain 約束) \n \n base shape and coordinate setup: \n 建立 Box 時的局部座標系統原點位於 Box Shape 中心, 由於 Box x 方向長度 1m, 因此將整體往 x 方向移動長度的一半 (即 0.5m), 可讓隨後定位完成的 link1 依照此座標系統指定旋轉中心. \n \n 幾何關係： \n 所有關節都繞 z 軸旋轉 \n 連桿長度分別為 0.4m、0.6m、0.9m \n 基座長度為 1m \n 物理特性： \n 所有連桿質量為 0.1kg \n 使用密度為 -1 表示質量優先於密度 \n 馬達最大速度 1rad/s，最大扭矩 100N⋅m \n 控制系統： \n 使用 "fourbar_controller" 控制器 \n 包含位置感測器和馬達裝置 \n fourbar_box.7z \n 1. \n \n 2. \n \n 3. \n \n 4. \n \n 5. \n \n 6. \n \n 7. \n \n 8. \n \n handon1 \n 啟動 Webots 2025a: \n 啟動可攜程式系統後, 可以在 cmd 命令視窗中執行 webotsw, 就可以啟動 Webots. \n 建立 Robot 模擬場景: \n 建立模擬場景可以在既有的 WorldInfo、ViewPoint、TextureBackground 以及 TextureBackgroundLight, 建立一個 Robot 節點. \n 利用 children 數列節點, 納入子節點: \n 之後的物件節點都可以在 Robot 節點中的 children 數列節點中建立, Robot 與 Solid 節點中都包含 children 數列節點, 表示這樣的節點可以透過 children 放入更多的子節點, 其中更包括將其他 Robot 與 Solid 節點納入作為子節點. \n 在 Shape 節點中建立標準物件: \n 至於 Shape 節點中, 就沒有 children 數列節點的設置, 只能根據其既有的節點屬性進行配置. 相較於 Solid 節點 Shape 節點的功能只能放入對應的標準物件, 例如: 目前這個範例會用到的 Box. \n 物件的移動與旋轉: \n 而 Robot 與 Solid 節點, 除了本身具備座標轉換的平移及旋轉術性外, 還能利用其中的 children 數列節點, 加入 Pose 節點進行子節點內的座標轉換, 還可利用 Transform 節點調整物件的 scale. \n 利用 CAD 繪圖 (Solvespace 或 Siemens NX) 協助機構定位: \n 本頁面的目的是利用 Webots 的 box 建立一個平面四連桿機構的模擬場景, 機構的尺寸設計必須從 Solvespace 的繪圖開始, 除了選擇各桿件的尺寸外, 還需提供各連桿的初始位置以及連桿方位, 才能透過 HingeJoint 以及 SolidReference 等兩個節點的配置, 完成平面四連桿的封閉機構約束設置. \n 物件的座標系統: \n 在 Webots 中建立模擬場景, 很重要的一項工作就是確認每一個物件場景的座標系統, 尤其是在某一物件節點中配置各種 Joint 之後, 隨後接在此 Joint 上的物件都將依據其 parent 座標系統定位. \n 連接軸樹狀架構與 CoppeliaSim 的差異: \n 此外 Webots 在配置 Joint 時的樹狀結構與 CoppeliaSim 有很大的差別, CoppeliaSim 的 Joint 物件位階是設定為 parent 物件的子物件, 而 Weobts 場景中的 Joint 節點則必須配置成與其 parent 節點相同位階. \n 利用 Box 建立平面四連桿模擬場景: \n 以下的配置圖是希望平面四連桿的固定桿件長度為 1m, 且透過 Top view 視圖觀測時, 會水平置放. 在 Robot 節點中的 children 建立 Solid 時使用 DEF 命名為 base, 隨後若要使用此 Solid, 就可以透過 USE base 引用. \n 但若此 DEF 命名物件之後, 內部的 Solid 物件自行移動 (例如: 透過 Pose), 則利用 USE base 作為 boundingObject 時, 也必須配合 Pose 移動至 Solid 所在位置. 如此才可在物件的碰撞檢測中, 正確配置物件的實體範圍. \n 起始座標定位方法一: \n 為了之後在此固定節點的左側建立 joint1, 因此將 base 平移 0.5m, 以便讓隨後配置的 HingeJoint 可以採用此座標系統進行配置. 但利用滑鼠點選 DEF base Solid 時, 可以發現物件的座標系統仍位於其物件中心: \n \n 但若將滑鼠停到 Robot 的節點上, 目前的廣域座標系統已經因為 translation 0.5 0 0 而移動到 base 的最左側, 因此隨後配置的 HingeJoint 將會依照此廣域座標系統進行後續配置: \n \n 起始座標定位方法二: \n 上列做法在一開始就先移動 base 物件, 讓隨後的 Joint1 定位中心可直接位於 base 左端. 若 base 物件不希望移動 (當 base 連桿與其他機構有特定對應位置時), 則隨後的 Joint1 就必須以 base 物件的中心點座標為基準, 然後在此基準建立 link1 物件之後, 先將 link1 移動至 base 最左端後旋轉 90 度, 這時的 x 軸將向上為正, 只要再沿著 x 軸移動 link1 長度的一半, 就可以完成 link1 的定位. \n 至於採用此方法的 Joint1 參考座標原點是位於 base 的中心點, 因此 link1 以 Joint1 旋轉的 anchor 中心點座標必須設為 -0.5 0 0. \n 之後的 link2 與 Joint2 的相關設置, 也可以採用先移動物件中心再旋轉至該連桿的起始方位後, 再對機構進行 x 軸方向的移動, 且對應旋轉的 Joint2 anchor 也必須配合設置當下的連桿參考座標系統. \n box 平面四連桿的 Robot 節點架構: \n 在 BASE 物件上設置兩個旋轉軸 (JOINT1 與 JOINT4): \n 其中的 JOINT1 上將接 link1, link1 上接 JOINT2, JOINT2 上接 link2, link2 上接 JOINT3, JOINT3 上接 link3, 意即從 BASE 上接了三個 joints, 以及三個 links, 形成一個 open chain 機構. \n 然後在 JOINT4 連接 link3 的設置時, 透過 SolidReference 節點, 指定 link3 作為 solidName 後, 將此條件作為 closed chain 的約束運算. \n 再加上從 CAD 繪圖中取得的各連桿起始位置, 就可以結合連桿的 physics 與 boundingObject 屬性設置, 完成 Webots 上的平面四連桿場景. \n \n 在 BASE 上配置 JOINT1, JOINT1 末端配置 LINK1, LINK1 上再配置 JOINT2 的樹狀架構圖如下: \n \n 將 Robot 命名為 four_bar_linkage, 並利用名稱為 fourbar_controller 的控制器進行控制: \n \n fourbar2 \n Webots 中平面四連桿機構的設置方式： \n 四連桿結構應該是： \n \n \n 第一條運動鏈 ： \n \n 從 BASE 出發的 JOINT1 \n JOINT1 連接 LINK1 \n LINK1 上的 JOINT2 連接 LINK2 \n LINK2 上的 JOINT3 連接 LINK3 \n \n \n \n 第二條運動鏈（closed chain） ： \n \n 從 BASE 出發的 JOINT4 \n JOINT4 的 endPoint 設為 SolidReference \n SolidReference 的 solidName 設為 "LINK3" \n \n \n \n 這樣的結構是正確的，因為： \n \n 主要運動鏈（JOINT1 → LINK1 → LINK2 → LINK3）形成一個序列結構 \n 閉鎖鏈（JOINT4 → LINK3）通過 SolidReference 連接回主鏈的末端 \n 這樣可以形成一個完整的閉環運動結構 \n \n 基本結構示意： \n BASE ├── JOINT1 → LINK1 → JOINT2 → LINK2 → JOINT3 → LINK3 └── JOINT4 ------(SolidReference: "LINK3")--------┘ \n PROTO 結構： \n Robot {\n  children [\n    BASE {\n      ...\n    }\n    HingeJoint {  # JOINT1\n      endPoint Solid {  # LINK1\n        children [\n          ...\n          HingeJoint {  # JOINT2\n            endPoint Solid {  # LINK2\n              children [\n                ...\n                HingeJoint {  # JOINT3\n                  endPoint Solid {  # LINK3\n                    ...\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    }\n    HingeJoint {  # JOINT4\n      endPoint SolidReference {\n        solidName "LINK3"\n      }\n    }\n  ]\n} \n 上列設置確保： \n \n 機構能夠正確形成閉環 \n 運動學約束能夠正確傳遞 \n 物理模擬能夠正常進行 \n \n 此外，為了使機構運作正常，還需要： \n \n 正確設置各個 joint 的旋轉軸（axis） \n 準確定義各個 joint 的錨點（anchor） \n 確保所有連桿的物理屬性正確設置 \n \n fourbar_slvs.7z \n DEF \n https://cyberbotics.com/doc/reference/def-and-use \n Although it is permitted to name any node using the DEF keyword,  there are some exceptions where USE nodes are not valid. A USE node is an exact copy of the corresponding DEF node, and thus no property of a USE node can change independently from the DEF node. \n For this reason it is not allowed to insert USE nodes of  Solid ,  Joint ,  JointParameters ,  TrackWheel , and  BallJointParameters  nodes and their derived nodes. Indeed, the ability for identical solids or joints to occupy the same position is useless, if not hazardous, in a physics simulation. To safely duplicate one of these nodes, you can design a  PROTO  model for this node and then add different PROTO instances to your world. \n The same principle applies to  Material  and  Light  nodes located in the first child of  Charger  and  LED  nodes whose emissive color changes automatically based on the  Charger  energy and  LED  setup. \n Also the  TextureTransform  of the first  Shape  in the  Track  device with enabled texture animation cannot be a USE node given that the translation values will be automatically updated by Webots while the  Track  device is moving. \n Webots  使用  DEF  和  USE  關鍵字來命名和重複使用節點的限制： \n \n \n DEF 和 USE 節點： \n \n \n DEF  關鍵字用來命名一個節點，這個節點可以在場景中多次使用。 \n \n \n USE  節點是  DEF  節點的精確複製，因此  USE  節點的所有屬性都會與它所引用的  DEF  節點完全相同，無法獨立修改其屬性。 \n \n \n \n \n 某些節點不能使用 USE： \n \n \n 有些節點不能作為  USE  節點使用，這些節點包括  Solid 、 Joint 、 JointParameters 、 TrackWheel  和  BallJointParameters  節點以及它們的衍生節點 。原因是，在物理仿真中，讓相同的實體或關節出現於相同位置是沒有意義的，甚至會帶來危險。例如，物理仿真需要每個實體或關節能夠獨立運動和改變位置，使用  USE  節點可能會導致錯誤的物理行為。 \n \n \n 若要安全地重複這些節點，應該使用  PROTO  模型來設計這些節點，並為每個需要的實例創建不同的  PROTO  實例，這樣可以避免重複的節點引起問題。 \n \n \n \n \n 特殊節點的限制： \n \n \n 同樣的原則也適用於某些特殊節點，如  Material  和  Light  節點 ，這些節點通常是位於  Charger  和  LED  節點的第一個子節點內。這些節點的發光顏色會根據充電器的能量或 LED 的設置自動變化，因此不能用  USE  來複製，否則會引起不一致的行為。 \n \n \n \n \n Track 設備的限制： \n \n \n 如果 Track 設備啟用了紋理動畫，則 Track 設備中的第一個  Shape  節點的  TextureTransform  也不能使用  USE 。這是因為 Webots 會在 Track 設備移動時自動更新其平移（Translation）值，使用  USE  節點會使這些自動更新失效，從而導致動畫或行為不正確。 \n \n \n \n \n Forbar Linkage the first link: \n #VRML_SIM R2025a utf8\n\nEXTERNPROTO "../protos/TexturedBackground.proto"\nEXTERNPROTO "../protos/TexturedBackgroundLight.proto"\n\nWorldInfo {\n  info [\n    "fourbar linkage"\n  ]\n}\nViewpoint {\n  orientation -0.17524366601960317 0.20799757991102616 0.9623027924053665 1.7913508311753839\n  position 1.0571588458938594 -2.502126861220829 1.490364369030099\n}\nTexturedBackground {\n}\nTexturedBackgroundLight {\n}\nDEF FOURBAR Robot {\n  children [\n    DEF BASE Solid {\n      children [\n        CadShape {\n          url [\n            "../split_parts/base.obj"\n          ]\n        }\n      ]\n      name "BASE"\n    }\n    DEF JOINT1 HingeJoint {\n      jointParameters HingeJointParameters {\n        axis 0 0 1\n      }\n      device [\n        RotationalMotor {\n          name "joint_motor1"\n        }\n      ]\n      endPoint DEF LINK1 Solid {\n        children [\n          CadShape {\n            url [\n              "../split_parts/link1.obj"\n            ]\n          }\n        ]\n        name "LINK1"\n      }\n    }\n  ]\n}\n \n Webots 中平面四連桿機構的設置方式： \n 四連桿結構應該是： \n \n \n 第一條運動鏈 ： \n \n 從 BASE 出發的 JOINT1 \n JOINT1 連接 LINK1 \n LINK1 上的 JOINT2 連接 LINK2 \n LINK2 上的 JOINT3 連接 LINK3 \n \n \n \n 第二條運動鏈（closed chain） ： \n \n 從 BASE 出發的 JOINT4 \n JOINT4 的 endPoint 設為 SolidReference \n SolidReference 的 solidName 設為 "LINK3" \n \n \n \n 這樣的結構是正確的，因為： \n \n 主要運動鏈（JOINT1 → LINK1 → LINK2 → LINK3）形成一個序列結構 \n 閉鎖鏈（JOINT4 → LINK3）通過 SolidReference 連接回主鏈的末端 \n 這樣可以形成一個完整的閉環運動結構 \n \n 基本結構示意： \n BASE ├── JOINT1 → LINK1 → JOINT2 → LINK2 → JOINT3 → LINK3 └── JOINT4 ------(SolidReference: "LINK3")--------┘ \n PROTO 結構： \n Robot {\n  children [\n    BASE {\n      ...\n    }\n    HingeJoint {  # JOINT1\n      endPoint Solid {  # LINK1\n        children [\n          ...\n          HingeJoint {  # JOINT2\n            endPoint Solid {  # LINK2\n              children [\n                ...\n                HingeJoint {  # JOINT3\n                  endPoint Solid {  # LINK3\n                    ...\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    }\n    HingeJoint {  # JOINT4\n      endPoint SolidReference {\n        solidName "LINK3"\n      }\n    }\n  ]\n} \n 上列設置確保： \n \n 機構能夠正確形成閉環 \n 運動學約束能夠正確傳遞 \n 物理模擬能夠正常進行 \n \n 此外，為了使機構運作正常，還需要： \n \n 正確設置各個 joint 的旋轉軸（axis） \n 準確定義各個 joint 的錨點（anchor） \n 確保所有連桿的物理屬性正確設置 \n \n fourbar_slvs.7z \n', 'tags': '', 'url': 'Fourbar.html'}, {'title': 'w10', 'text': 'w10_2b_hw1_hw2_demo.7z \n 以下模擬將 joint4 定在 link3 末端, 然後透過 SolidReference 指定為 <static environment>, 表示此 joint4 必須固定在地面. \n', 'tags': '', 'url': 'w10.html'}, {'title': 'Stage1', 'text': '學習利用 Webots 建立模擬場景的第一階段工作, 是認識其套件功能表與場景所需的目錄及檔案架構. 並且學習如何利用控制器程式操縱場景中的物件. 這也是  Tutorial1  操作的主要目的. \n Tutorial2  則說明如何使用 Webots 內建的標準幾何物件, 其中的物件幾何外形除了用於動力系統的運動方程式, 還可用於物體移動時的碰撞檢測. 建立物件時必須遵照 Solid - Shape - physics 的樹狀結構規劃, 按照順序配置物件.', 'tags': '', 'url': 'Stage1.html'}, {'title': 'Tutorial1', 'text': '導引課程 本章的目的是解說 Webots 的基本概念，這些概念是自行創建模擬場景 (.wbt) 時必須用到的。學習重點在於機器人及其環境的模型建構，以及機器人控制器 (controllers) 的程式設計。您還將學習如何尋找進一步的教學資料。 本章適合 Webots 的初學者。不過，仍然需要有程式設計 (Programming) 的背景。範例是用 Python 語言編寫的。如果您不熟悉 Python 語言，您仍然應該能夠理解本章，因為下面的 Python 程式非常簡單。除了程式設計，您不需要任何特定的知識即可完成本章中的教程。然而，基本的機器人學 (Robotcs)、數學 (Mathematics)、模型建構 (Modeling) 和樹狀表示法 (Tree representation) 的背景知識可能會有所幫助。有經驗的 Webots 使用者可以跳過最初的教程。不過，我們建議他們至少閱讀這些教程的介紹和結論。 本章的每個部分（除了第一和最後一部分）都是一個導引課程。每個導引課程都有一個明確的教育目標，並在第一段中進行解釋。獲得的概念隨後會在結論子部分中總結。每一個導引課程都被設計成一系列互動步驟。要繼續進行下一個教程，通常需要掌握前一個教學中獲得的知識。因此，我們強烈建議您按照它們的自然順序進行。此外，我們建議您在繼續進一步之前，確保您已經理解了導引課程中的所有概念。 最後一部分將為您提供一些解決本章未涉及問題的提示。 導引課程的解決方案位於 Webots 安裝目錄的 "WEBOTS_HOME/projects/samples/tutorials" 子目錄中。 \n 導引課程 1：在 Webots 中進行您的第一次模擬 目標 本導引課程的目標是讓您熟悉用戶界面和 Webots 的基本概念。您將創建一個包含簡單環境的首次模擬：一個帶有地板和牆壁的競技場、幾個箱子、一個 e-puck 機器人和一個使機器人移動的控制程式。 步驟 1. 啟動 Webots：在您的電腦上打開 Webots (假如使用協同產品設計課程的可攜套件，啟動後在命令列中輸入 webotsw 即可開啟 Webots)。 \n 實作 #1：通過雙擊 Webots 圖標（或在終端中從命令行調用）來啟動 Webots。如果您是第一次在此電腦上運行 Webots，可能會提示您選擇圖形主題。您也可能被邀請參加 Webots 指導遊覽，請關閉指導遊覽。 \n 2. 創建新世界： \xa0\xa0\xa0 - 轉到 File -> New World。 \xa0\xa0\xa0 - 使用適當的名稱保存新世界文件，例如 my_first_simulation.wbt。 \n 3. 添加競技場： \xa0\xa0\xa0 - 在場景樹中，右鍵點擊 root 並選擇 Add New -> Solid。 \xa0\xa0\xa0 - 將新固體重命名為 arena 並為其添加 Shape。 \xa0\xa0\xa0 - 將其幾何形狀設置為 Box，並設置適當的尺寸（例如，1m x 1m x 0.01m）來表示地板。 \xa0\xa0\xa0 - 為形狀添加 Material 並設置其顏色。 \n 實作 #2：通過點擊 3D 視圖的暫停按鈕來暫停當前模擬（請參閱用戶界面描述以找到按鈕）。如果主工具欄上的虛擬時間計數器停止，則模擬被暫停。從 File / New / New Project Directory... 菜單項創建一個新項目並按照說明進行： 1. 將項目目錄命名為 my_first_simulation，而不是建議的 my_project。 2. 將世界文件命名為 my_first_simulation.wbt，而不是建議的 empty.wbt。 3. 點擊所有選框，包括默認未選中的 "Add a rectangle arena"。 \n 4. 添加牆壁： \xa0\xa0\xa0 - 重複該過程以在競技場周圍添加四面牆壁。 \xa0\xa0\xa0 - 調整它們的位置和尺寸以適合地板周圍。 \n 實作 #3：在場景樹中雙擊 RectangleArena 節點。這應該會打開該節點並顯示其字段。 1. 選擇 floorTileSize 字段並將其值設置為 0.25 0.25 而不是 0.5 0.5。您應該立即在 3D 視圖中看到效果。 2. 選擇 wallHeight 字段並將其值更改為 0.05 而不是 0.1。競技場的牆壁現在應該變得更低。 \n 5. 添加箱子： \xa0\xa0\xa0 - 在競技場內添加幾個箱子作為障礙物。 \xa0\xa0\xa0 - 根據您的喜好設置它們的位置和尺寸。 \n 實作 #4：在場景樹中雙擊 RectangleArena 以將其關閉並選中它。點擊場景樹頂部的添加按鈕。在打開的對話框中，選擇 PROTO nodes (Webots Projects) / objects / factory / containers / WoodenBox (Solid)。一個大箱子應該會出現在競技場的中央。在場景樹中雙擊它以打開其字段。 1. 將其尺寸更改為 0.1 0.1 0.1 而不是 0.6 0.6 0.6。 2. 將其平移更改為 0 0 0.05 而不是 0 0 0.3。或者，您可以使用 3D 視圖中出現的藍色箭頭來調整其 translation.z 字段。 3. 現在按住 Shift 鍵並在 3D 視圖中拖動箱子，將其移動到競技場的某個角落。 4. 選擇箱子並按 ctrl-C，ctrl-V（Windows，Linux）或 ⌘ command-C，⌘ command-V（macOS）來複製和粘貼它。按住 Shift 鍵並拖動新箱子將其移動到某個不同的位置。以這種方式創建第三個箱子。 5. 移動箱子，使競技場中央沒有箱子。您也可以使用藍色旋轉箭頭沿垂直軸旋轉箱子。這也可以通過按住 Shift 鍵並用右鍵拖動來完成。或者，您可以更改場景樹中 WoodenBox 節點的旋轉字段的角度。 6. 一旦您對結果滿意，請使用保存按鈕保存世界。 \n 6. 添加 e-puck 機器人： \xa0\xa0\xa0 - 在場景樹中，右鍵點擊 root 並選擇 Add New -> Robot。 \xa0\xa0\xa0 - 從可用機器人列表中選擇 e-puck 機器人。 \n 實作 #5：選擇場景樹視圖中的最後一個節點 WoodenBox。點擊場景樹視圖頂部的添加按鈕。在對話框中，選擇 PROTO nodes (Webots Projects) / robots / gctronic / e-puck / E-puck (Robot)。一個 e-puck 機器人應該會出現在競技場的中央。像移動和旋轉箱子一樣移動和旋轉這個機器人。保存模擬並按下實時運行按鈕。 \n 7. 創建控制程式： \xa0\xa0\xa0 - 在場景樹中右鍵點擊 e-puck 並選擇 Add New -> Controller。 \xa0\xa0\xa0 - 創建一個新的控制器文件（例如，epuck_controller.c）並編寫一個簡單的程式來使機器人移動。例如： \n from controller import Robot, Motor  # 從 controller 模組導入 Robot 和 Motor 類別\n\nTIME_STEP = 64  # 設置時間步長為 64 毫秒\n\n# 創建 Robot 實例\nrobot = Robot()\n\n# 擷取電機設備\nleftMotor = robot.getDevice(\'left wheel motor\')  # 獲取左側輪子電機設備\nrightMotor = robot.getDevice(\'right wheel motor\')  # 獲取右側輪子電機設備\n\n# 設置電機的目標位置\nleftMotor.setPosition(10.0)  # 設置左側輪子電機的目標位置為 10.0\nrightMotor.setPosition(10.0)  # 設置右側輪子電機的目標位置為 10.0\n\nwhile robot.step(TIME_STEP) != -1:  # 當機器人步進時間步長不等於 -1 時（模擬仍在運行）\n    pass  # 什麼也不做，保持循環運行 \n 8. 保存並運行模擬： \xa0\xa0\xa0 - 保存您的世界文件。 \xa0\xa0\xa0 - 點擊 Play 按鈕運行模擬並觀察機器人移動。 結論 在本導引課程中，您已經學習了如何在 Webots 中創建一個簡單的模擬，包括添加競技場、牆壁、障礙物和 e-puck 機器人。您還創建了一個基本的控制程式來使機器人移動。本導引課程已經為您探索 Webots 更進階功能提供了充實的基礎。 \n', 'tags': '', 'url': 'Tutorial1.html'}, {'title': 'Tutorial2', 'text': '導引課程 2：修改環境 在本導引課程中，我們將教您如何在環境中創建簡單的物件。第一步將是創建一個與環境互動的球。我們將處理與節點相關的幾個概念：它們的含義是什麼，如何創建它們，它們如何必須隸屬等等。此外，我們還將看到如何設置物理效果。 將介紹幾種節點類型。它們的詳細定義可以在 參考手冊 中找到。將 節點圖表 放在您面前，將有助於理解節點的繼承關係。 \n 一個新的模擬 首先，我們基於教程 1 中創建的模擬來創建一個新的模擬。 \n 實作 #1：確保 my_first_simulation.wbt 世界文件已打開，並且模擬已暫停且虛擬時間為 0。使用 File / Save World As... 菜單將模擬保存為 obstacles.wbt。 \n 修改地板 內定的 RectangleArena PROTO 定義了一個簡單的地板，固定在靜態環境中，沒有物理節點，四周則被牆壁包圍。Webots 物件庫中還有其他預製的地板。我們現在將刪除 RectangleArena 節點，並添加一個簡單的地板，稍後在本教程中我們將手動用牆壁圍繞它。 \n 實作 #2：要刪除 RectangleArena，請在 3D 視圖或場景樹視圖中選中它，然後按鍵盤上的 del 鍵。或者，您可以在 3D 視圖中右鍵單擊它，然後在上下文菜單中選擇 Delete（您也可以直接在場景樹視圖中使用上下文表單）。選擇 TexturedBackgroundLight 節點並點擊添加按鈕。在打開的對話框中，選擇 PROTO nodes (Webots Projects) / objects / floors / Floor (Solid)。 \n 新添加的 Floor PROTO 默認大小為 10 米 x 10 米，但可以通過更改相應的字段來調整其大小、位置和紋理。 \n 實作 #3：在場景樹視圖中選擇並展開 Floor。修改 size 字段並將其設置為 {1, 1} 以將其調整為 1 米 x 1 米。 \n Solid  節點 本小節介紹了 Webots 中最重要的基礎節點： Solid  節點，許多其他節點都從它衍生而來。 Solid  節點代表剛體，即可以忽略變形的物體。剛體中任意兩點之間的距離無論外力如何作用，都保持恆定。例如桌子、機器人手指骨節或輪子都是剛體。軟體和關節物體不是剛體。例如繩子、輪胎、海綿或關節機器人手臂都不是剛體。然而，一個關節實體可以被分解成若干剛體。 Webots 的物理引擎設計用於模擬剛體。設計模擬時，一個重要的步驟是將各種實體分解為單獨的剛體。 要定義剛體，您需要創建一個  Solid  節點。在此節點內，您將設置對應於剛體特性的不同子節點。下圖描述了一個剛體及其子節點。 Solid  節點的圖形表示由填充其子級列表的形狀節點定義。碰撞範圍在其 boundingObject 字段中定義。圖形表示和碰撞形狀通常但不必然相同。最後，physics 字段定義物體屬於動態環境還是靜態環境。所有這些子節點都是可選的，但 physics 字段需要定義 boundingObject。 \n \n 在 Webots 中，最簡單的剛體模型具有 幾何外形圖示  (以 Shape 中的 Geometry 標示其 視覺外形 )、 物理邊界形體  (以 boundingObject 中的 Geometry 標示其 碰撞檢測外形 ) 並處於 動態環境  (以 physics 中的 Physics 標示其 物理特性參數 ) 中。 圖中的幾何框代表任何類型的幾何原始體。事實上，它可以被替換為球體、盒子、圓柱體等。 \n 創建一個球 我們現在將在模擬中添加一個球。該球將被建模為剛體，如下圖所示。我們將使用  Sphere  節點來定義我們球的幾何形狀。 \n 實作 #4：在場景樹視圖中，選擇最後一個節點並按「Add」按鈕。在對話框中，打開「Bases nodes」部分並選擇「 Solid 」節點。在場景樹視圖中，展開「 Solid 」節點並選擇其「children」字段。使用「Add」按鈕向其添加一個「 Shape 」節點。選擇「 Shape 」節點的「appearance」字段，並使用「Add」按鈕添加一個「PBRAppearance」節點。 \xa0\xa0\xa0 添加一個「Sphere」節點作為新創建的「 Shape 」節點的幾何字段。 \xa0\xa0\xa0 展開「PBRAppearance」節點，將其「metalness」字段更改為 0，並將其「roughness」字段更改為 1。 \xa0\xa0\xa0 向「 Solid 」的「boundingObject」字段添加另一個「 Sphere 」節點。 \xa0\xa0\xa0 最後，向「 Solid 」的「physics」字段添加一個「Physics」節點。 \xa0\xa0\xa0 通過修改「 Solid 」節點的「translation」字段，將球放置在機器人前面（例如在 {0.2, 0, 0.2}）。 \xa0\xa0\xa0 保存模擬。 \xa0\xa0\xa0 結果如下圖所示。 \n \n 你的第一個 Webots 剛體 當模擬開始時，球會撞擊地板。您可以通過對球施加力來移動它（ctrl + alt + 左鍵單擊並拖動）。通過啟用 View / Optional Rendering / Show Contact Points 表單項，可以顯示球與地板之間的接觸點作為青色線條。 \n 幾何體 為了定義球，我們在兩個不同的上下文中使用了 Sphere 節點：圖形表示 (graphical representation)（children）和定義物理邊界 (physical bounds)（boundingObject）。所有幾何節點（例如 Sphere 節點）都可以在圖形標示中使用。但是，只有其中的一部分可以在物理標示中使用。 節點圖表 中則明確指出哪些節點可以用在何種標示。(這裡需要進一步說明各節點的適用情境) 我們現在將縮小球體的尺寸，並通過增加用於表示它的三角形數量來提高其圖形質量。 \n 實作 #5：對於定義球的每個 Sphere 節點，將其 radius 字段設置為 0.05，將其 subdivision 字段設置為 2。請參考  sphere 手冊 了解 subdivision 字段的含義。 \n DEF-USE 機制 DEF-USE 機制允許在一個地方定義一個節點，並在場景樹的其他地方重用該定義。這對於避免在世界文件中重複相同的節點非常有用。此外，它還允許用戶同時修改多個對象。其工作原理如下：首先使用 DEF 字符串標記一個節點。然後可以使用 USE 關鍵字在其他地方重用該節點的副本。只有 DEF 節點的字段可以編輯，USE 節點的字段繼承自 DEF 節點，無法更改。此機制依賴於世界文件中節點的順序。DEF 節點應在任何相應的 USE 節點之前定義。 我們之前用來定義球的兩個 Sphere 定義是冗餘的。我們現在將使用 DEF-USE 機制將這兩個 Sphere 合併為一個。 \n 實作 #6：在場景樹視圖中選擇第一個 Sphere 節點（Shape 的子節點）。場景樹視圖的字段編輯器允許您輸入 DEF 字符串。 \xa0\xa0\xa0 在此字段中輸入 BALL_GEOMETRY。 \xa0\xa0\xa0 選擇 boundingObject 字段（包含第二個 Sphere 節點），通過右鍵單擊該字段並選擇彈出上下文菜單中的「Delete」條目來清空它。 \xa0\xa0\xa0 然後，選擇 boundingObject 字段並單擊「Add」按鈕，在對話框中選擇 USE / BALL_GEOMETRY。 \xa0\xa0\xa0 結果如圖所示。 \n 現在，更改第一個 Sphere 節點的 radius 字段也會修改其 boundingObject。 為了方便起見，boundingObject 字段也接受  Shape  節點（而不是直接接受 Sphere 節點）。同樣可以在  Shape  層級使用相同的 DEF-USE 機制，如下圖所示。目前最大的好處是能夠直接將此  Shape  用於圖形目的。稍後此機制對於某些傳感器將非常有用。 \n \n 在名為 BALL_GEOMETRY 的 Sphere 節點上使用 DEF-USE 機制。 \n \n 在 Solid 的 幾何體的 Sphere 節點上應用 DEF-USE 機制 。 \n 實作 #7：創建第二個球，使用相同的參數，但使用  Shape  節點（而不是直接使用 Sphere 節點）來實現 DEF-USE 機制。 \n 添加牆壁 為了驗證您的進展，請自行實現四面牆來圍繞環境。這些牆必須靜態地定義到環境中。為了理解靜態和動態之間的區別，讓我們取一個地面上的定義物體（球）。如果 Physics 節點為 NULL，它將在模擬期間保持靜止在空中（靜態情況）。如果 physics 字段包含 Physics 節點，它將在重力作用下掉落（動態情況）。 儘量在 Shape  層級使用 DEF-USE 機制，而不是在 Geometry 層級。確實，將中間 Shape 節點添加到 Solid 節點的 boundingObject 字段中更方便。實現牆壁的最佳幾何原語是  Box  節點。所有牆壁只需定義一個  Shape 。預期結果如圖所示。 \n 實作 #8：添加四面牆，無需物理效果，並且只使用一個 Shape 節點的定義。 \n 解決方案：世界文件 要將您的世界與解決方案進行比較，請進入您的文件並找到在 導引課程1 中創建的名為 "my_first_simulation" 的文件夾，然後進入 "worlds" 文件夾並用文本編輯器打開相應的世界文件。此解決方案與其他解決方案位於 solution 目錄中。 \n \n 在本教程結束時的模擬狀態。 \n 效率 剛體的模擬計算代價高昂。通過最小化邊界對象的數量、最小化它們之間的約束（有關約束的更多信息在後續教程中），以及最大化 WorldInfo.basicTimeStep 字段，可以提高模擬速度。在每次模擬中，必須在模擬速度和現實感之間找到權衡。 \n 結論 在本教程結束時，您將能夠基於剛體創建簡單的環境。您能夠從場景樹視圖中添加節點並修改其字段。您已經熟悉了  Solid 、Physics、 Shape 、Sphere 和  Box  節點。您還看到了 DEF-USE 機制，該機制允許減少場景樹的節點冗餘。 \n', 'tags': '', 'url': 'Tutorial2.html'}, {'title': 'Stage2', 'text': 'Webots 進入第二階段, 包含零件的外觀 ( Tutorial3 ), 控制與感測 ( Tutorial4 ), 以及複合外形零件的建構 ( Tutorial5 ) 等議題. \n Homework1  僅使用簡單的 Box 建立平面四連桿機構場景. 若利用  Tutorial5  中的 Group 節點, 就能整合出更多外形的零組件. \n Homework2  雖然使用 MCAD 套件繪製機構所需零件, 但因為在組立時各零件已經完成定位, 因此使用上, 只要透過  CadShape  導入 obj 格式的零件檔案, 即可在模擬場景中套用, 至於各連桿  Solid  節點中的 boundingObject 欄位, 只要利用  Mesh  節點中的 url 指向物件 obj 檔案即可. \n 至於  hingeJoint  中的  HingeJointParameters  則宣告該轉軸所在位置 (anchor) 以及旋轉軸 (axis) 即可. \n Homework3  投籃機的實現則必須使用  Tutorial4  中的控制與感測技術. \n', 'tags': '', 'url': 'Stage2.html'}, {'title': 'Tutorial3', 'text': '導引課程 3：外觀 本導引課程的目的是讓你熟悉一些與圖形渲染相關的節點。當這些節點被適當使用時，可以很快創建出外觀良好的模擬。良好的圖形質量不僅能提升用戶體驗，對於機器人感知其環境的模擬（如攝像頭圖像處理、循線等）也是至關重要的。 本教學結束時的效果如下圖所示。 \n \n 新模擬 \n 實作 #1：創建新模擬 從上一個教程的結果中，通過使用檔案 / 另存世界... 菜單創建一個名為 "appearance.wbt" 的新模擬。 \n 燈光 世界的燈光由燈光節點 ( Light ) 和背景 ( Background ) 決定。燈光節點有三種類型：方向燈 ( DirectionalLight )、單點燈 ( PointLight ) 和聚光燈 ( SpotLight )。方向燈模擬無限遠的光源（例如：太陽），點燈模擬從單一點發出的光（例如：燈泡），而聚光燈模擬錐形光（例如：手電筒）。下面這張圖展示了它們之間的比較。每種類型的燈光節點都可以投射陰影。你可以在 參考手冊 中找到它們的完整文檔。 \n \n 三種在 Webots 中可能的燈光比較。左邊是方向燈 (DirectionalLight)，中間是聚光燈 (SpotLight)，右邊是點燈 (PointLight)。 \n 在模擬中設置燈光就性能上需要耗費運算資源，會降低模擬速度（尤其是在投射陰影時）。最小化燈光數量可以提高渲染速度。單點燈 (PointLight) 比聚光燈 (SpotLight) 更高效，但比方向燈 (DirectionalLight) 效率低。 在本次模擬中，燈光節點在場景樹中不可見，因為它包含在  TexturedBackgroundLight  PROTO 節點中。它由一個方向燈 (DirectionalLight) 組成，其強度和方向根據場景背景自動計算。 修改牆壁的外觀 本小節的目標是將牆壁顏色改為藍色。 形狀節點 ( Shape ) 的外觀 ( Appearance ) 和 PBR 外觀 ( PBRAppearance ) 節點決定了物件的圖形外觀。在其他方面，這些節點負責物件的顏色和紋理。 如以下比較所示，建議使用 PBR 外觀以獲得更好的渲染效果。 \n \n 外觀節點 (Appearance) 和 PBR 外觀節點 (PBRAppearance) 的比較。左邊是外觀節點 (Appearance)，右邊是 PBR 外觀節點 (PBRAppearance)。 \n PBRAppearance 節點指定了一個節點的基於物理的視覺外觀。縮寫 "PBR" 指的是 "Physically-Based Rendering"（基於物理的渲染），這個術語用來表示一類基於物體物理特性的著色模型，而不是像在 Appearance 節點中使用的 Blinn-Phong BRDF 這樣的更古老的模型。 \n Blinn–Phong  反射模型，也稱為修改的 Phong 反射模型，是由  Jim Blinn  開發的  Phong 反射模型 的修改版本。 Blinn–Phong 是一種在 OpenGL 和 Direct3D 的固定功能管線（在 Direct3D 10 和 OpenGL 3.1 之前）中使用的著色模型，並在每個頂點上進行處理，當它通過圖形管線時；頂點之間的像素值默認由  Gouraud  著色插值，而不是計算成本更高的  Phong  著色。 \n 實作 #2：在圖形表示第一面牆的形狀節點 (Shape) 中，將 PBRAppearance 節點添加到外觀 (Appearance) 欄位。 - 使用顏色選擇器將其 baseColor 欄位設置為藍色。 - 使用欄位編輯器將其 metalness 欄位設置為 0。 - 最後，使用欄位編輯器將其 roughness 欄位設置為 0.5。 - 如果上一個教程中的 DEF-USE 機制正確實施，所有牆壁應該都會變成藍色。 \n 添加現有的外觀到球體 Webots 發行版中提供了許多預定義的 PBRAppearance。 \n 實作 #3：添加預定義的 PBRAppearance \xa0\xa0\xa0 選擇外觀 (appearance) 欄位並刪除之前添加的節點。要刪除此節點，可以按鍵盤上的 "delete" 鍵，或右鍵點擊該欄位並從菜單中選擇 "delete"。此欄位現在應顯示為 "appearance NULL" 而不是 "appearance PBRAppearance"。 \xa0\xa0\xa0 再次雙擊該欄位，然後導航到 PROTO 節點 (Webots Projects)，再導航到 appearances，並選擇 OldSteel (PBRAppearance)。 \n 添加硬碟中儲存的紋理 本小節的目標是將本地可用的紋理應用到球上。在滾動的物體加上紋理可更容易檢視其運動情況。 \n 實作 #4：將本地可用的紋理添加到球體。 1. 下載 這裡 所提供的紋理並將其儲存到硬碟中。 2. 從外觀 (appearance) 欄位中刪除先前添加的節點，並改為添加一個 PBRAppearance 節點。 3. 向 PBRAppearance 節點的 baseColorMap 欄位添加一個 ImageTexture 節點。 4. 使用 "Add" 按鈕向 ImageTexture 的 url 欄位添加一個項目。 5. 然後使用 "Select" 按鈕設置新添加的 url 項目的值。 6. 跟隨路徑到您保存紋理的位置並選擇它。 \n 紋理 URL 必須定義為相對於專案目錄的 worlds 目錄或相對於預設專案目錄 WEBOTS_HOME/projects/default/worlds。 在圖像查看器中打開 red_brick_wall.jpg 紋理，同時觀察它如何映射到 Webots 中的 Sphere 節點上。 紋理根據參考手冊中描述的預定義 UV 映射函數映射到幾何節點上。UV 映射函數將 2D 圖像表示映射到 3D 模型。 \n \n 在設置好 Light 和 PBRAppearance 節點後的模擬。 \n 渲染選項 Webots 在視圖菜單中提供了幾種渲染模式。 \n 實作 #5：使用"視圖 / 線框渲染" (View / Wireframe Rendering) 表單項以線框模式查看模擬。然後還原為普通渲染模式："視圖 / 普通渲染" (View / Plain Rendering)。 \n 其他渲染功能也很有幫助： \xa0\xa0\xa0 查看座標系統： View / Optional Rendering / Show Coordinates System 或使用 ctrl-F1 \xa0\xa0\xa0 查看距離傳感器光線： View / Optional Rendering / Show DistanceSensor Rays 或使用 ctrl-F10 \n 解決方案：世界文件 要將您的世界與解決方案進行比較，請轉到您的文件並找到在  Tutorial1 中創建的名為 my_first_simulation 的文件夾，然後轉到 worlds 文件夾並使用文本編輯器打開正確的世界文件。 此解決方案 和其他解決方案位於 解決方案目錄 中。 結論 在本導引課程中，您學習了如何使用  PBRAppearance  節點和光源節點設置一個美觀的環境。 您可以通過閱讀參考手冊中這些節點的詳細描述來進一步了解此主題。此 常見問題 解答將為您提供有效設置這些節點的方法。 \n', 'tags': '', 'url': 'Tutorial3.html'}, {'title': 'Tutorial4', 'text': "導引課程 4：更多關於控制器的內容 現在我們開始討論與編程機器人控制器相關的主題。我們將設計一個簡單的控制器來避開在前面的教程中創建的障礙物。 本教程將介紹 Webots 中機器人編程的基礎。在本章結束時，您應該了解場景樹節點與控制器 API 之間的關聯，如何初始化和清理機器人控制器，如何初始化機器人設備，如何獲取傳感器值，如何指令執行器，以及如何編程一個簡單的反饋迴路。 本教程僅涉及 Webots 功能的正確使用。機器人算法的研究超出了本教程的目標，因此不會在此處討論。掌握一些基本的編程知識是解決本章問題的必要條件（任何 C 教程應該都是足夠的入門介紹）。在本章的末尾，提供了進一步的機器人算法的鏈接。 \n 新的模擬場景與控制器 \n 實作 #1：將之前的世界保存為 collision_avoidance.wbt。從文件/新建/新建機器人控制器菜單項中創建一個新的 C（或任何其他語言）控制器，命名為 epuck_avoid_collision（對於 C++ 和 Java，命名為 EPuckAvoidCollision）。修改 E-puck 節點的控制器字段以將其與新控制器關聯。 \n Hands on #1: Save the previous world as collision_avoidance.wbt. Create a new C (or any other language) controller called epuck_avoid_collision (for C++ and Java call it EPuckAvoidCollision instead) from the File / New / New Robot Controller... menu item. Modify the controller field of the E-puck node in order to associate it to the new controller. \n Reminder: How to create a new controller? Select the File / New / New Robot Controller... menu item and choose your programming language and the file name. \n 了解 e-puck 模型 控制器編程需要一些與 e-puck 模型相關的信息。為了創建碰撞檢測算法，我們需要讀取其炮塔周圍的 8 個紅外距離傳感器的值，並且我們需要驅動其兩個輪子。下圖展示了距離傳感器在炮塔周圍的分佈情況以及 e-puck 的方向。 距離傳感器在機器人層次結構中由 8 個  DistanceSensor  節點建模。這些節點通過它們的名稱字段進行引用（從 ps0 到 ps7）。我們將在稍後解釋這些節點是如何定義的。目前，只需注意可以通過 Webots API 的相關模塊訪問 DistanceSensor 節點（通過 webots/distance_sensor.h 標頭文件）。距離傳感器返回的值在 0 到 4096 之間縮放（線性分段到距離）。4096 表示測量到大量光（障礙物很近），而 0 表示沒有測量到光（沒有障礙物）。 控制器 API 是一個編程接口，它使您能夠訪問機器人的模擬傳感器和執行器。例如，包含 webots/distance_sensor.h 文件允許使用 wb_distance_sensor_* 函數，通過這些函數可以查詢 DistanceSensor 節點的值。API 函數的文檔可以在 參考手冊 中找到，並附有每個節點的描述。 \n \n e-puck 模型的上視圖。綠色箭頭表示機器人的前方。紅色線條代表紅外距離傳感器的方向。字符串標籤對應於距離傳感器的名稱。 \n \n 簡單回饋迴路的 UML 狀態機 \n 編寫控制器程序 我們想要編程一個非常簡單的碰撞避免行為。您將編程使機器人向前行駛，直到前方距離傳感器檢測到障礙物，然後轉向無障礙物的方向。為了做到這一點，我們將使用在圖中的 UML 狀態機中所示的簡單反饋迴路。 此控制器的完整代碼在下一小節中給出。 \n 動手操作 #2：在控制器文件的開頭，添加對應於 Robot、DistanceSensor 和 Motor 節點的導入指令，以便能夠使用相應的 API： from controller import Robot, DistanceSensor, Motor 在導入語句之後，定義一個變量，用於定義每個物理步長的持續時間。這個宏將用作 Robot::step 函數的參數，它也將用於啟用設備。這個持續時間以毫秒為單位，必須是 WorldInfo 節點的 basicTimeStep 字段值的倍數。 TIME_STEP = 64 \n 主函數是控制器程序開始執行的地方。傳遞給主函數的參數由 Robot 節點的 controllerArgs 字段給出。必須使用 wb_robot_init 函數初始化 Webots API，並使用 wb_robot_cleanup 函數清理它。 \n 動手操作 #3：在 Python 中沒有主函數，程序從文件的開始處開始執行： \n # create the Robot instance.\nrobot = Robot()\n# initialize devices\n# feedback loop: step simulation until receiving an exit event\nwhile robot.step(TIME_STEP) != -1:\n    # read sensors outputs\n    # process behavior\n    # write actuators inputs \n 機器人設備由 WbDeviceTag 引用。WbDeviceTag 由 wb_robot_get_device 函數檢索。然後，它在每個涉及此設備的函數調用中用作第一個參數。像 DistanceSensor 這樣的傳感器在使用前必須啟用。enable 函數的第二個參數定義了傳感器的刷新率。 \n 動手操作 #4：在註釋 // initialize devices 之後，獲取並啟用距離傳感器，如下所示： \n # initialize devices\nps = []\npsNames = [\n    'ps0', 'ps1', 'ps2', 'ps3',\n    'ps4', 'ps5', 'ps6', 'ps7'\n]\n\nfor i in range(8):\n    ps.append(robot.getDevice(psNames[i]))\n    ps[i].enable(TIME_STEP) \n 初始化設備後，初始化馬達： \n leftMotor = robot.getDevice('left wheel motor')\nrightMotor = robot.getDevice('right wheel motor')\nleftMotor.setPosition(float('inf'))\nrightMotor.setPosition(float('inf'))\nleftMotor.setVelocity(0.0)\nrightMotor.setVelocity(0.0) \n 在主循環中，在註釋 # read sensors outputs 之後，按如下方式讀取距離傳感器的值： \n # read sensors outputs\npsValues = []\nfor i in range(8):\n    psValues.append(ps[i].getValue()) \n 在主循環中，在註釋 # process behavior 之後，檢測是否發生碰撞（即距離傳感器返回的值大於閾值），如下所示： \n # detect obstacles\nright_obstacle = psValues[0] > 80.0 or psValues[1] > 80.0 or psValues[2] > 80.0\nleft_obstacle = psValues[5] > 80.0 or psValues[6] > 80.0 or psValues[7] > 80.0 \n 最後，使用有關障礙物的信息來驅動車輪，如下所示： \n MAX_SPEED = 6.28\n...\n# initialize motor speeds at 50% of MAX_SPEED.\nleftSpeed  = 0.5 * MAX_SPEED\nrightSpeed = 0.5 * MAX_SPEED\n# modify speeds according to obstacles\nif left_obstacle:\n    # turn right\n    leftSpeed  = 0.5 * MAX_SPEED\n    rightSpeed = -0.5 * MAX_SPEED\nelif right_obstacle:\n    # turn left\n    leftSpeed  = -0.5 * MAX_SPEED\n    rightSpeed = 0.5 * MAX_SPEED\n# write actuators inputs\nleftMotor.setVelocity(leftSpeed)\nrightMotor.setVelocity(rightSpeed) \n Save your code by selecting the File / Save Text File menu item. Reload the world. \n 控制器代碼 以下是前一小節中詳細介紹的控制器完整代碼。 \n from controller import Robot, DistanceSensor, Motor\n\n# time in [ms] of a simulation step\nTIME_STEP = 64\n\nMAX_SPEED = 6.28\n\n# create the Robot instance.\nrobot = Robot()\n\n# initialize devices\nps = []\npsNames = [\n    'ps0', 'ps1', 'ps2', 'ps3',\n    'ps4', 'ps5', 'ps6', 'ps7'\n]\n\nfor i in range(8):\n    ps.append(robot.getDevice(psNames[i]))\n    ps[i].enable(TIME_STEP)\n\nleftMotor = robot.getDevice('left wheel motor')\nrightMotor = robot.getDevice('right wheel motor')\nleftMotor.setPosition(float('inf'))\nrightMotor.setPosition(float('inf'))\nleftMotor.setVelocity(0.0)\nrightMotor.setVelocity(0.0)\n\n# feedback loop: step simulation until receiving an exit event\nwhile robot.step(TIME_STEP) != -1:\n    # read sensors outputs\n    psValues = []\n    for i in range(8):\n        psValues.append(ps[i].getValue())\n\n    # detect obstacles\n    right_obstacle = psValues[0] > 80.0 or psValues[1] > 80.0 or psValues[2] > 80.0\n    left_obstacle = psValues[5] > 80.0 or psValues[6] > 80.0 or psValues[7] > 80.0\n\n    # initialize motor speeds at 50% of MAX_SPEED.\n    leftSpeed  = 0.5 * MAX_SPEED\n    rightSpeed = 0.5 * MAX_SPEED\n    # modify speeds according to obstacles\n    if left_obstacle:\n        # turn right\n        leftSpeed  = 0.5 * MAX_SPEED\n        rightSpeed = -0.5 * MAX_SPEED\n    elif right_obstacle:\n        # turn left\n        leftSpeed  = -0.5 * MAX_SPEED\n        rightSpeed = 0.5 * MAX_SPEED\n    # write actuators inputs\n    leftMotor.setVelocity(leftSpeed)\n    rightMotor.setVelocity(rightSpeed) \n 解決方案：世界文件 要將您的世界與解決方案進行比較，請轉到您的文件並找到在  Tutorial1  中創建的名為 my_first_simulation 的文件夾，然後轉到 worlds 文件夾並使用文本編輯器打開正確的世界。此解決方案與其他解決方案位於解決方案目錄中。 結論 以下是您剛剛學到的關鍵點的快速摘要： - 控制器入口點是主函數，就像任何標準的 C 程序一樣。 - 在調用 wb_robot_init 函數之前，不應調用任何 Webots API 函數。 - 離開主函數之前要調用的最後一個函數是 wb_robot_cleanup 函數。 - 設備由其設備節點的名稱字段引用。可以通過 wb_robot_get_device 函數檢索節點的引用。 - 每個控制器程序都作為 Webots 進程的子進程執行。控制器進程不與 Webots 共享任何內存（除了相機的圖像），並且它可以在與 Webots 不同的 CPU（或 CPU 核心）上運行。 - 控制器代碼鏈接到 libController 動態庫。該庫處理控制器與 Webots 之間的通信。 本節更詳細地解釋了控制器編程。您應該仔細閱讀以進一步了解在 Webots 中的機器人編程。", 'tags': '', 'url': 'Tutorial4.html'}, {'title': 'Tutorial5', 'text': '導引課程 5：複合固體和物理屬性 \n 本導引課程的目的是通過創建一個具有多個邊界對象的固體來更詳細地探索物理模擬：一個由兩個球體和一個圓柱體組成的啞鈴。預期結果如圖所示。 \n \n 預期結果在教程結束時，您將能夠創建一個由兩個球體和一個圓柱體組成的啞鈴，如圖所示。 \n 新的模擬 \n 實作練習 #1：從上一個教程的結果開始，並通過使用表單 File / Save World As.... 創建一個名為 compound_solid.wbt 的新模擬。 \n Compound Solid \n It is possible to build  Solid  nodes more complex than what we have seen before by aggregating  Shape  nodes. In fact, both the physical and the graphical properties of a  Solid  can be made of several  Shape  nodes. Moreover each  Shape  node can be placed in a  Pose  node in order to change its relative position and orientation.  Group  nodes can also be used to group several sub-nodes. \n We want to implement a dumbbell made of a handle ( Cylinder ) and of two weights ( Sphere ) located at each end of the handle. This  figure  depicts the  Solid  nodes and its sub-nodes required to implement the dumbbell. \n Hands on #2: Create the dumbbell by following the figure. Create the handle first without placing it in a Pose node (so the handle axis will have the same direction as the z-axis of the solid). The handle should have a length of 0.1 m and a radius of 0.01 m. The weights should have a radius of 0.03 m and a subdivision of 2. The weights can be moved at the handle extremities thanks to the translation field of their Pose nodes. \n \n representation of the subnodes of a compound solid made of several transformed geometries. \n Physics Attributes \n The aim of this subsection is to learn how to set some simple physics properties for a  Solid  node. The  Physics  node contains fields related to the physics of the current rigid body ( Solid ). \n The  mass  of a  Solid  node is given by its  density  or  mass  field. Only one of these two fields can be specified at a time (the other should be set to  -1 ). When the  mass  is specified, it defines the total mass of the solid (in [kg]). When the  density  is specified, its value (in [kg/m3]) is multiplied by the volume of the bounding objects, and the product gives the total mass of the solid. A density of 1000 [kg/m³] corresponds to the density of water (default value). \n Hands on #3: Set the mass of the dumbbell to 2 [kg]. The density is not used and should be set to -1. \n By default, the  center of mass  of a  Solid  node is set at its origin (defined by the translation field of the solid). The center of mass can be modified using the  centerOfMass  field of the  Physics  node. The center of mass is specified relatively to the origin of the  Solid . \n Hands on #4: Let\'s say that one of the weights is heavier than the other one. Move the center of mass of the dumbbell of 0.01 [m] along the z-axis. \n Note that when the solid is selected, the center of mass is represented in the 3D view by a coordinate system which is darker than the coordinate system representing the solid center. \n The Rotation Field \n The  rotation  field of the  Pose  node determines the rotation of this node (and of its children) using the  Euler axis and angle  representation. A  Euler axis and angle  rotation is defined by four components. The first three components are a unit vector that defines the rotation axis. The fourth component defines the rotation angle about the axis (in [rad]). \n The rotation occurs in the sense prescribed by the right-hand rule. \n Hands on #5: Modify the rotation of the Solid node of the dumbbell in order to move the handle\'s axis (z-axis) parallel to the ground. A unit axis (0, 1, 0) and an angle of π/2 (~ 1.5708) is a possible solution. \n How to Choose Bounding Objects? \n As said before, minimizing the number of bounding objects increases the simulation speed. However, choosing the bounding objects primitives carefully is also crucial to increase the simulation speed. \n Using a combination of  Sphere ,  Box ,  Capsule  and  Cylinder  nodes for defining objects is very efficient. Generally speaking, the efficiency of these primitives can be sorted like this:  Sphere  >  Box  >  Capsule  >  Cylinder , where the  Sphere  is the most efficient. But this can be neglected under common usage. \n The  IndexedFaceSet  geometry primitive can also be used in a bounding object. But this primitive is less efficient than the other primitives listed above. Moreover its behavior is sometimes buggy. For this reasons, we don\'t recommend using the  IndexedFaceSet  when another solution using a combination of the other primitives is possible. \n Grounds can be defined using the  Plane  or the  ElevationGrid  primitives. The  Plane  node is much more efficient than the  ElevationGrid  node, but it can only be used to model a flat terrain while the  ElevationGrid  can be used to model an uneven terrain. \n Contacts \n When two solids collide,  contacts  are created at the collision points.  ContactProperties  nodes can be used to specify the desired behavior of the contacts (e.g. the friction between the two solids). \n Each solid belongs to a material category referenced by their  contactMaterial  field ( default  by default). The  WorldInfo  node has a  contactProperties  field that stores a list of  ContactProperties  nodes. These nodes allow to define the contact properties between two categories of  Solids . \n We want now to modify the friction model between the dumbbell and the other solids of the environment. \n Hands on #6: Set the contactMaterial field of the dumbbell to "dumbbell". In the WorldInfo node, add a ContactProperties node between the default and dumbbell categories. Try to set the coulombFriction field to 0 and remark that the dumbbell slides (instead of rotating) on the floor because no more friction is applied. \n basicTimeStep ,  ERP  and  CFM \n The most critical parameters for a physics simulation are stored in the  basicTimeStep ,  ERP  and  CFM  fields of the  WorldInfo  node. \n The  basicTimeStep  field determines the duration (in [ms]) of a physics step. The bigger this value is, the quicker the simulation is, the less precise the simulation is. We recommend values between  8  and  16  for regular use of Webots. \n It\'s more difficult to explain the behavior of the  ERP  and  CFM  fields. These values are directly used by the physics engine to determine how the constraints are solved. The default values are well defined for regular use of Webots. We recommend to read the  Reference Manual  and the documentation of  ODE  (physics engine used in Webots) to understand completely their purpose. \n Minor Physics Parameters \n There are also other physics parameters which are less useful in a regular use of Webots, for example some of the fields of the  Physics ,  WorldInfo  and  ContactProperties  nodes. \n Hands on #7: Search how to add a linear damping on all the objects, how to use the inertia matrix and how to use the physicsDisableTime property. \n Solution: World File \n To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in  Tutorial 1 , then go to the "worlds" folder and open with a text editor the right world.  This solution  as the others is located in the  solution directory . \n Conclusion \n You are now able to build a wide range of solids including those being composed of several rigid bodies. You know that a Geometry node can be moved and rotated if it is included in a  Pose  node. You are aware about all the physics parameters allowing you to design robust simulations. The next step will be to create your own robot. \n You can test your skills by creating common objects such as a table. \n', 'tags': '', 'url': 'Tutorial5.html'}, {'title': 'Stage3', 'text': 'Tutorial6  是學習如何建立及控制行動機器人. \n Tutorial7  說明如何自行建立原型物件 (PROTO). \n Tutorial8  就自行開發投籃機模擬場景而言, 可在虛擬的模擬場景中, 利用 supervisor 模式配置非可實際達成的程式控制加速虛實產品的開發流程.', 'tags': '', 'url': 'Stage3.html'}, {'title': 'Tutorial6', 'text': 'Tutorial 6: 4-Wheeled Robot \n This tutorial aims at creating your first robot from scratch. The robot will consist of a body, four wheels, and two distance sensors. The result is depicted on  this figure . The  next figure  shows the robot from a top view. \n \n 3D view of the 4 wheels robot. Note that the coordinate system representations of the robot body and of its wheels are oriented the same way. Their +x-vector (in red) defines the left of the robot, their +y-vector (in green) defines the top of the robot, and their +z-vector (in blue) defines the front of the robot. The distance sensors are oriented in a different way, their +x-vector indicates the direction of the sensor. \n \n Top view of the 4 wheeled robot. The grid behind the robot has a dimension of 0.2 x 0.3 meters. The text labels correspond to the name of the device. \n New Simulation \n \n Hands on #1 : Save the world of the previous tutorial as \xa0 4_wheeled_robot.wbt . Remove the nodes defining the e-puck, the ball, the dumbbell and the contact properties. The ground, the walls and the lighting are kept. \n \n Separating the Robot in Solid Nodes \n Some definitions and rules to create the robot model: \n \n \n The set containing the \xa0 Solid \xa0 node and all its derived nodes are called the \xa0 solid nodes . \n \n \n A similar definition is applied for the \xa0 Device , \xa0 Robot , \xa0 Joint \xa0 and \xa0 Motor \xa0 nodes. You can get more information about the node hierarchy in the \xa0 nodes chart diagram . \n \n \n Most sensors and actuators are both \xa0 Solid \xa0 and \xa0 Device \xa0 nodes at the same time. \n \n \n The main structure of a \xa0 Robot \xa0 model is a tree of \xa0 Solid \xa0 nodes linked together. The root node of this tree should be a \xa0 Robot \xa0 node. \n \n \n The solids are linked together by \xa0 Joint \xa0 nodes. A \xa0 Device \xa0 node should be the direct child of either a \xa0 Robot \xa0 node, a \xa0 Solid \xa0 node or a \xa0 Joint \xa0 node. \n \n \n A \xa0 Joint \xa0 node is used to add one (or two) degree(s) of freedom (DOF), between its parent and its child. The direct parent and child of a \xa0 Joint \xa0 node are both \xa0 Solid \xa0 nodes. \n \n \n The nodes derived from \xa0 Joint \xa0 allow creating different kinds of constraints between the linked \xa0 Solid \xa0 nodes. The most used one in robotics, is the \xa0 HingeJoint \xa0 allowing to model amongst others rotational motors including wheels. \n \n \n A \xa0 Joint \xa0 node can be monitored or actuated by adding a \xa0 PositionSensor \xa0 node, or a motor node to its \xa0 device \xa0 field respectively. \n \n \n Having these rules in mind, we can start designing the node hierarchy used to model the robot. The first step is to determine which part of the robot should be modeled as a \xa0 Solid \xa0 node. \n In our example, this operation is quite obvious. The robot has 4 DOF corresponding to the wheel motors. It can be divided in five solid nodes: the body and the four wheels. \n Depending on the expected application of the robot model, reducing the DOF while modelling might be necessary to get an efficient simulation. For example, when modeling a caster wheel, a realistic approach implies to model 2 DOF. But if this degree of precision is useless for the simulation, a more efficient approach can be found. For example, to model the caster wheel as a \xa0 Sphere \xa0 having a null friction coefficient with the ground. \n The second step is to determine which \xa0 Solid \xa0 node is the \xa0 Robot \xa0 node (the root node). This choice is arbitrary, but a solution is often much easier to implement. For example, in the case of a humanoid robot, the robot node would be typically the robot chest, because the robot symmetry facilitates the computation of the joint parameters. \n In our case, the body box is obviously the better choice. The \xa0 figure \xa0 depicts the solid nodes hierarchy of the robot. \n \n Hands on #2 : At the end of the scene tree, add a \xa0 Robot \xa0 node having four \xa0 HingeJoint \xa0 nodes having a \xa0 Solid \xa0 node as \xa0 endPoint . Please refer to \xa0 this figure . Add a \xa0 Shape \xa0 node containing a Box geometry to the \xa0 Robot \xa0 node. Set the color of the \xa0 Shape \xa0 to red. Use the \xa0 Shape \xa0 to define the \xa0 boundingObject \xa0 field of the \xa0 Robot \xa0 node. The dimension of the box is \xa0 (0.2, 0.1, 0.05) . Add a \xa0 Physics \xa0 node to the \xa0 Robot . The \xa0 figure \xa0 represents all the nodes defining the robot. So far, only the direct children nodes of the root \xa0 Robot \xa0 node has been implemented. \n \n \n High level representation of the 4 wheeled robot \n HingeJoint \n The initial position of the wheel is defined by the translation and the rotation fields of the \xa0 Solid \xa0 node. \n The rotation origin (anchor) and the rotation axis (axis) are defined by the optional \xa0 HingeJointParameters \xa0 child of the \xa0 HingeJoint \xa0 node. \n \n Representation of a hinge joint \n The radius of the wheel is 0.04 and its thickness (height of the cylinder) is 0.02. For the first wheel, the \xa0 Solid \xa0 translation should be defined to \xa0 (0.05, 0.06, 0) \xa0 in order to define the relative gap between the body and the wheel, and the rotation to \xa0 (1 0 0 1.5708) \xa0 for the wheel cylinder to be correctly oriented. The \xa0 HingeJointParameters \xa0 anchor should also be defined to \xa0 (0.05, 0.06, 0) \xa0 to define the rotation origin (relatively to the body). Finally, the \xa0 HingeJointParameters \xa0 axis should define the rotation axis. In our case it\'s along the y-axis (so \xa0 (0, 1, 0) ). \n \n Hands on #3 : Add a \xa0 HingeJointParameters \xa0 node, and enter the field values as described above. Some signs obviously have to be updated for other wheels. \n \n Now, let\'s implement the cylinder shape of the wheels. \n For each \xa0 HingeJoint , there are three fields in which nodes need to be added. \n \n jointParameters : Add a \xa0 HingeJointParameters \xa0 and configure the anchor (0.05 -0.06 0) and axis (0 1 0) fields. These values have to be modified according to the location of the wheel. \n device : Add a \xa0 RotationalMotor \xa0 in order to be able to actuate the wheels. Change their \xa0 name \xa0 fields from \xa0 wheel1 \xa0 to \xa0 wheel4 \xa0 according to \xa0 this figure . These labels will be used to reference the wheels from the controller. \n endPoint : Add a \xa0 Solid \xa0 node, then a \xa0 Shape \xa0 node in the \xa0 children \xa0 field of the \xa0 Solid , and finally, add a \xa0 Cylinder \xa0 in the \xa0 geometry \xa0 field of the \xa0 Shape \xa0 node. The \xa0 Cylinder \xa0 should have a \xa0 radius \xa0 of \xa0 0.04 \xa0 and a \xa0 height \xa0 of \xa0 0.02 . Set the color of the wheels to green. \n \n \n Hands on #4 : Complete the missing nodes to get the same structure as the \n one depicted in \xa0 this figure . Don\'t forget the \xa0 Physics \xa0 nodes. \n \n \n Low level representation of the 4 wheeled robot \n Sensors \n The sensors used on the e-puck of \xa0 Tutorial 4 \xa0 are not the same as the ones used in this section. Pay attention to their measuring interval which is between \xa0 0 cm = 0 \xa0 and \xa0 10 cm = 1000 . Find more information about the \xa0 lookupTable \xa0 field \xa0 here . \n The last part of the robot modeling is to add the two distance sensors to the robot. This can be done by adding two \xa0 DistanceSensor \xa0 nodes as direct children of the \xa0 Robot \xa0 node. Note that the distance sensor acquires its data along the positive x-axis. So, it is necessary to rotate the distance sensor to point their x-axis outside the robot (see the \xa0 figure ). \n \n \n \n \n \n \n \n \n \n \n \n Reminder : How to know the orientation of the distance sensor? As already says in \xa0 Tutorial 3 , the distance sensor rays can be viewed using the shortcut \xa0 ctrl - F10 \xa0 or \xa0 View / Optional Rendering / Show DistanceSensor Rays .\n \n Hands on #5 : Add the two distance sensors as explained above. The distance sensors are at an angle to 0.3 [rad] with the front vector of the robot. Set the graphical and physical shape to a cube (not transformed) having a edge of \xa0 0.01 \xa0 [m]. Set the color to blue. Set the \xa0 name \xa0 field according to the labels of \xa0 this figure . \n \n Tips : How to precisely orient distance sensors? In the \xa0 DistanceSensor \xa0 node, the rotation field has 4 parameters. If you set the angle parameter to 0, then you can use the mouse wheel to increment/decrement by steps of 0.1309 rad (= 7.5 degree).\n Controller \n In the previous tutorials, you have learnt how to setup a feedback loop and how to read the distance sensor values. However, actuating a \xa0 RotationalMotor \xa0 node is something new. To program the rotational motors, the first step is to include the API module corresponding to the \xa0 RotationalMotor \xa0 node: \n \n from  controller  import  Motor\n \n \n Then to get the references of the \xa0 RotationalMotor \xa0 nodes: \n \n # initialize motors \nwheels = []\nwheelsNames = [ \'wheel1\' ,  \'wheel2\' ,  \'wheel3\' ,  \'wheel4\' ]\n for  name  in  wheelsNames:\n    wheels.append(robot.getDevice(name))\n \n \n A \xa0 Motor \xa0 can be actuated by setting its position, its velocity, its acceleration or its force. Here we are interested in setting its velocity. This can be achieved by setting its position to infinity, and by bounding its velocity: \n \n speed =  -1.5    # [rad/s] \nwheels[ 0 ].setPosition(float( \'inf\' ))\nwheels[ 0 ].setVelocity(speed)\n \n \n \n Hands on #6 : Implement a controller called \xa0 four_wheeled_collision_avoidance \xa0 moving the robot and avoiding obstacles by detecting them by the distance sensors. \n \n Note that the \xa0 lookupTable \xa0 field of the \xa0 DistanceSensor \xa0 nodes indicates the values returned by the sensor. To help in the debugging with the sensors, it is possible to see the value of the sensors in the real-time in the \xa0 robot-window . To open the \xa0 robot-window , double-click on the robot body and it will bring up a menu on the left with the \xa0 DistanceSensor \xa0 and \xa0 RotationalMotor \xa0 graph. Run the simulation to see the evolution. \n Don\'t forget to set the \xa0 controller \xa0 field of the \xa0 Robot \xa0 node to indicate your new controller. \n As usual a possible solution of this exercise is located in the tutorials directory. \n The Controller Code \n Here is the complete code of the controller developed in the previous subsection. \n from controller import Robot\n\nTIME_STEP = 64\nrobot = Robot()\nds = []\ndsNames = [\'ds_right\', \'ds_left\']\nfor i in range(2):\n    ds.append(robot.getDevice(dsNames[i]))\n    ds[i].enable(TIME_STEP)\nwheels = []\nwheelsNames = [\'wheel1\', \'wheel2\', \'wheel3\', \'wheel4\']\nfor i in range(4):\n    wheels.append(robot.getDevice(wheelsNames[i]))\n    wheels[i].setPosition(float(\'inf\'))\n    wheels[i].setVelocity(0.0)\navoidObstacleCounter = 0\nwhile robot.step(TIME_STEP) != -1:\n    leftSpeed = 1.0\n    rightSpeed = 1.0\n    if avoidObstacleCounter > 0:\n        avoidObstacleCounter -= 1\n        leftSpeed = 1.0\n        rightSpeed = -1.0\n    else:  # read sensors\n        for i in range(2):\n            if ds[i].getValue() < 950.0:\n                avoidObstacleCounter = 100\n    wheels[0].setVelocity(leftSpeed)\n    wheels[1].setVelocity(rightSpeed)\n    wheels[2].setVelocity(leftSpeed)\n    wheels[3].setVelocity(rightSpeed) \n Solution: World File \n To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in \xa0 Tutorial 1 , then go to the "worlds" folder and open with a text editor the right world. \xa0 This solution \xa0 as the others is located in the \xa0 solution directory . \n Conclusion \n You are now able to design simple robot models, to implement them and to create their controllers. \n More specifically, you learnt all the different nodes involved in the design of a robot model, methods to translate and rotate a solid relative to another and the way that a rotational motor is actuated by the controller. \n', 'tags': '', 'url': 'Tutorial6.html'}, {'title': 'Tutorial7', 'text': 'Tutorial 7: Your First PROTO \n The aim of this tutorial is to create a PROTO file corresponding to the four wheels robot from the previous tutorial. \n Copy the Robot Definition \n For now, the definition of the robot is completely contained in the world file. Moving this definition in a PROTO file will allow you to use this robot without the need to completely copy and paste its definition (either several times in the same world or in different worlds). \n \n Hands-on #1 : Open the world \xa0 4_wheels_robot.wbt \xa0 created in the previous tutorial in your favorite text editor. Create a new empty text file in the \xa0 protos \xa0 folder of your project called \xa0 FourWheelsRobot.proto \xa0 and open this file in the text editor too, this file will contain the definition of your robot. \n \n Any PROTO file should at least respect the following structure: \n #VRML_SIM R2025a utf8\nPROTO protoName [\n  protoFields\n]\n{\n  protoBody\n} \n The \xa0 protoName \xa0 should be the name of the PROTO file (i.e. \xa0 FourWheelsRobot \xa0 in this case), \xa0 protoFields \xa0 defines the modifiable fields of the PROTO node (this part should be empty for now) and the \xa0 protoBody \xa0 is the definition of the root node (i.e. the \xa0 Robot \xa0 node in this case). \n \n Hands-on #2 : Write this default structure in your PROTO file with the correct \xa0 protoName . From the \xa0 4_wheels_robot.wbt \xa0 world file copy the robot node (starting with \xa0 Robot { \xa0 and ending with the final \xa0 } ) and paste it in your PROTO file instead of the \xa0 protoBody . Finally, save the PROTO file. \n \n Solution : You should have something like this: \n #VRML_SIM R2025a utf8\n  PROTO FourWheelsRobot [\n\n  ]\n  {\n    Robot {\n      # list of fields\n    }\n  } \n Use the PROTO Node. \n This new PROTO node is now available for each world in your current project. \n \n \n Hands-on #3 : Open the \xa0 4_wheels_robot.wbt \xa0 world in Webots and add the \xa0 FourWheelsRobot \xa0 node (that you just defined). The node is located in \xa0 PROTO nodes (Current Project) / FourWheelsRobot (Robot) . \n \n A second 4 wheels robot should have been added at the exact same location as the already existing one. \n Adding Fields \n As you probably noticed, this new PROTO node doesn\'t have any open field, it is therefore impossible to translate, rotate or change the controller for example. It is very easy to add new fields to a PROTO node and to link them with internal fields. This should be done in the PROTO interface part (part between the \xa0 [ \xa0 and the \xa0 ] ). \n \n Hands-on #4 : Edit your PROTO file in your text editor and add the definition of the \xa0 translation , \xa0 rotation \xa0 and \xa0 bodyMass \xa0 field in the PROTO interface part: \n \n   field SFVec3f    translation  0 0 0\n  field SFRotation rotation     0 0 1 0\n  field SFFloat    bodyMass     1\n \n Your PROTO node has now two open fields but they are not linked to any internal field. To link the fields you should use the IS keyword, simply replace the \xa0 translation x y z \xa0 and \xa0 rotation x y z angle \xa0 fields of the \xa0 Robot \xa0 node by: \n   translation IS translation\n  rotation IS rotation\n \n And the \xa0 mass \xa0 field of the \xa0 Physics \xa0 node of the \xa0 Robot \xa0 node by: \n   mass IS bodyMass\n \n Save your PROTO file, it should now look like this: \n #VRML_SIM R2025a utf8\nPROTO FourWheelsRobot [\n  field SFVec3f    translation  0 0 0\n  field SFRotation rotation     0 0 1 0\n  field SFFloat    bodyMass     1\n]\n{\n  Robot {\n    translation IS translation\n    rotation IS rotation\n    children [\n      # list of children nodes\n    ]\n    boundingObject USE BODY\n    physics Physics {\n      density -1\n      mass IS bodyMass\n    }\n    controller "four_wheels_collision_avoidance"\n  }\n} \n You can now save your simulation in Webots and revert it. The \xa0 translation , \xa0 rotation \xa0 and \xa0 bodyMass \xa0 of the \xa0 FourWheelsRobot \xa0 node can now be changed (either in the \xa0 scene tree \xa0 or using the handles in the \xa0 3D view ). \n The same mechanism could also be used to expose the \xa0 controller \xa0 field of the \xa0 Robot \xa0 node. \n Solution: PROTO File \n To compare your PROTO file with \xa0 the solution , go to your files and find the folder named "my_first_simulation" created in \xa0 Tutorial 1 , then go to the "protos" folder and open with a text editor the right PROTO. \n Conclusion \n You are now able to create PROTO nodes from any nodes you created in Webots. \n More specifically, you learnt how to copy the node definition in the PROTO file and how to open and link PROTO fields to internal node fields. \n To go further, the \xa0 PROTO chapter \xa0 of the reference manual explains in detail all the possibilities of the PROTO mechanism.', 'tags': '', 'url': 'Tutorial7.html'}, {'title': 'Tutorial8', 'text': 'Tutorial 8: The Supervisor \n A \xa0 Supervisor \xa0 oversees a world and can set or get information about it. This tutorial will teach you: \n \n How to move objects (移動物件) using the supervisor. \n How to delete a node (刪除節點) and spawn another (產生另一個節點) in its place. \n How to track the evolution of an object (追蹤物件演進) in the scene. \n How to change the properties of an object (改變物件性質) , namely its color (顏色). \n \n 若要使用類似 CoppeliaSim 場景中的 七段顯示器 , 以便建立數位記分板, 可以採用 Supervisor 控制器. (或者使用  Display  顯示分數) \n \n The \xa0 Display \xa0 node allows to handle a 2D pixel array using simple API functions, and render it into a 2D overlay on the 3D view, into a 2D texture of any \xa0 Shape \xa0 node, or both.  It can model an embedded screen or it can display any graphical information such as graphs, text, robot trajectory, filtered camera images  and so on. \n To model an embedded screen, the first child of the \xa0 Display \xa0 node should be or contain (recursive search if the first node is a \xa0 Group ) a \xa0 Shape \xa0 node having an appearance and an \xa0 ImageTexture \xa0 node, then the internal texture of the \xa0 ImageTexture \xa0 node is replaced by the texture of the \xa0 Display . Both \xa0 Appearance \xa0 and \xa0 PBRAppearance \xa0 nodes are supported. In case of \xa0 PBRAppearance \xa0 node, at least \xa0 PBRAppearance.baseColorMap \xa0 or \xa0 PBRAppearance.emissiveColorMap \xa0 ImageTexture \xa0 node should be defined. If both are defined, then both textures will be internally replaced by the \xa0 Display \xa0 texture. Using the \xa0 Appearance \xa0 node and setting the \xa0 Material .emissiveColor field to \xa0 1 1 1 \xa0 helps preserving the original colors of the loaded \xa0 Display \xa0 texture. Additionally, it is necessary to set the \xa0 filtering \xa0 field of the \xa0 ImageTexture \xa0 nodes to 0 in order to prevent issues when distancing oneself from the  display . \n Example: \n from controller import Supervisor\n\n# Create the Supervisor instance\nsupervisor = Supervisor()\n\n# Get the display node\ndisplay = supervisor.getDevice("display")\n\n# Set the initial digit\ndigit = 0\n\n# Set the font size\nfont_size = 24\n\n# Main loop\nwhile supervisor.step(int(supervisor.getBasicTimeStep())) != -1:\n    # Clear the display\n    display.setAlpha(1.0)\n    display.setColor(0x000000)\n    display.fillRectangle(0, 0, display.getWidth(), display.getHeight())\n    \n    # Draw the digit\n    display.setAlpha(1.0)\n    display.setColor(0xFFFFFF)\n    display.setFont("Arial", font_size, True)\n    display.drawText(str(digit), display.getWidth() // 2 - font_size, display.getHeight() // 2 - font_size)\n    \n    # Increment the digit\n    digit += 1\n    \n    # Reset the digit after 100\n    if digit > 100:\n        digit = 0 \n Display demo:\xa0 display_demo.7z \n \n 上列 Display 節點可應用於競技場景中的計時與計分流程 \n \n These are only some tasks the \xa0 Supervisor \xa0 is capable of, refer to its documentation for a complete overview. Just note that it is, however, not possible to access directly measurements recorded by devices mounted on a different robot even if the supervisor option is enabled. \n Setting up the Environment and Adding a Supervisor \n \n Hands-on #1 : The objective is to create the environment and add a Supervisor. Create a new project from \xa0 File / New / New Project Directory... \xa0 menu item and follow the instructions: \n \n Name the project directory \xa0 my_supervisor \xa0 instead of the proposed \xa0 my_project . \n Name the world file \xa0 my_supervisor.wbt \xa0 instead of the proposed \xa0 empty.wbt . \n Click all the tick boxes, including the "Add a rectangle arena" which is not ticked by default. (需要納入競技平台) \n In order to have more space, enlarge the arena by setting the size to 10x10 meters by changing the \xa0 floorSize \xa0 field. \n Add a \xa0 BB-8 \xa0 robot to the scene, to do this click the \xa0 Add \xa0 button \xa0 \xa0 and navigate to: \xa0 PROTO nodes (Webots projects) / robots / sphero / bb8 . \n For the purpose of this tutorial, remove the default controller of \xa0 BB-8 \xa0 by clicking the \xa0 controller \xa0 field, then the \xa0 Select \xa0 button, and pick \xa0 <none> \xa0 from the list. (移除原型節點中既有的控制器設定) \n Add a simple \xa0 Robot \xa0 node to the scene, this will become our Supervisor. The \xa0 Robot \xa0 node can be found in the \xa0 base nodes \xa0 category when clicking the \xa0 Add \xa0 button. To better keep track of it, change its \xa0 name \xa0 field to \xa0 supervisor . \n Despite the name change the node is still currently just a\xa0 Robot , to turn this robot into a\xa0 Supervisor \xa0requires to set its\xa0 supervisor \xa0field to "TRUE". \n Much like a normal robot, the behavior of a supervisor is defined by a controller. Add a controller using the \xa0 File / New / New Robot Controller... \xa0 menu item, selecting the programming language you prefer. For this tutorial, Python is the choice, but the code will be provided for all other options. Set \xa0 supervisor_controller \xa0 as the name of the controller and click finish (for C++ and Java call it \xa0 SupervisorController \xa0 instead). \n Expand once more the \xa0 Robot \xa0 node, press the \xa0 controller \xa0 field and click the \xa0 Select \xa0 button in order to attribute the controller you just created to the supervisor. \n Save the world. \n \n \n If you followed these steps, your environment should look like this: \n \n Resulting environment. \n Moving Objects Using a Supervisor \n So far our \xa0 Supervisor \xa0 is quite dull, because the controller that was attributed to it does nothing. \n In this section, we will program the supervisor to move the BB-8 robot to a different location.  It should be noted that to achieve this we are effectively cheating, rather than instructing the BB-8 to move to a new location we will transport it there . In other words the movement will ignore all the physics, but herein lies the power of a \xa0 Supervisor , as it can bend the rules however it likes. \n As you might have noticed, the default controller we created from the \xa0 File / New / New Robot Controller... \xa0 menu item is setup for a classic robot, not a supervisor. In order to access the powers of a supervisor requires therefore some slight changes to the controller. To begin with, replace the contents of the default controller with the following code, depending on the language you have picked and save. \n The changes include: \n \n import the Supervisor library/module instead of the Robot one \n instead of creating a\xa0 Robot \xa0instance, create a\xa0 Supervisor \xa0one. \n \n \n Note: \xa0 It is important to remember that a supervisor is nothing more than a robot with special powers, which implies that whatever a robot can do, so can the supervisor. This means that you do not need a \xa0 Robot \xa0 instance if you have a supervisor one. For example the infinite loop that determines the pace of the controller (namely: \xa0 while robot.step(TIME_STEP) != -1 ) does not need to be changed, as the supervisor can do the same. \n \n Here are the instructions to follow based on the programming language you picked. \n \n Replace the contents of your controller with the following and save. \n from controller import Supervisor\n\nTIME_STEP = 32\n\nrobot = Supervisor()  # create Supervisor instance\n\n# [CODE PLACEHOLDER 1]\n\ni = 0\nwhile robot.step(TIME_STEP) != -1:\n  # [CODE PLACEHOLDER 2]\n\n  i += 1 \n \n To move BB-8 to a new location is quite straightforward, if you wished to do so without the help of a supervisor you would simply change its \xa0 translation \xa0 field to the desired value, say \xa0 0 0 2.5 . The \xa0 Supervisor \xa0 does it much in the same way. \n \n \n Hands-on #2 : Move BB-8 using the Supervisor. In principle the world could be very complex, so it is necessary to have a way of uniquely identifying our BB-8 among the other objects. To do so we can use the \xa0 DEF \xa0 mechanism explored in \xa0 tutorial 2 . Click the BB-8 node in the scene tree and give it a \xa0 DEF \xa0 name "BB-8", then save the world. \n Behind the scenes, each node is uniquely identifiable by a node reference and by having this reference, we can modify it. To retrieve the reference, the supervisor method \xa0 getFromDef \xa0 can be used. In \xa0 CODE PLACEHOLDER 1 , retrieve the node reference of BB-8. \n bb8_node = robot.getFromDef( \'BB-8\' )\n \n Now that we have access to the node, we need to get access to its \xa0 translation \xa0 field, specifically we need a reference to this field as we just did for the node. To do so, the \xa0 getField \xa0 method can be used. \n translation_field = bb8_node.getField( \'translation\' )\n \n Finally, now that a reference to the translation field is available, all that remains to do is to set it to a different value. Once again, the supervisor API has all the necessary tools to do so. The \xa0 translation \xa0 field is of type \xa0 SFVec3 , which just means it is a three dimensional vector. The value of this field can be set by using the \xa0 setSFVec3f \xa0 method. \n if  i ==  0 :\n  new_value = [ 2.5 ,  0 ,  0 ]\n  translation_field.setSFVec3f(new_value)\n \n That is all there is to it. If you save and run the simulation you will see that BB-8 is transported to a new location instantly. \n \n \n This is a simple example, but the principle remains the same no matter which field you wish to change.  You can for instance increase the size of an object, perhaps change its color, change the light conditions, or reset its position if it goes out of bounds, the options are limitless. It is just a matter of getting a node reference, from which a field reference can be obtained by name, and set its value by using the function that is appropriate for the type you are trying to change. \n Spawning and Removing Nodes \n Supervisors can also be used to populate the environment, allowing to dynamically setup the scene. This section focuses on how nodes can be added and removed, specifically we will remove \xa0 BB-8 \xa0 from this world, and replace it with a different robot, namely \xa0 Nao . \n \n \n Hands-on #3 : Removing and adding nodes. In the previous section, we already saw how to retrieve the node reference of an object. A node can be removed from the scene tree by using the \xa0 remove \xa0 method.  The\xa0 if \xa0condition is not necessary, it simply adds a 10 step delay before the removal to make it more apparent.  Add the following code in \xa0 CODE PLACEHOLDER 2 . \n if  i ==  10 :\n  bb8_node.remove()\n \n After 10 time steps, \xa0 BB-8 \xa0 will be removed from the scene. Now, let\'s instead add the \xa0 Nao \xa0 robot after 20 time steps. \n In order to add a node, we must know where we wish to spawn it in the scene tree. Should it be added at the top level of the scene tree? Should it  inserted as a field of a another node ? These questions will change how the node will be inserted and which supervisor function needs to be used, but the constant factor among them is that we need a reference to this position. In this context, the \xa0 Nao \xa0 robot will be added at the last position in the scene tree, where BB-8 used to appear. \n First of all, we need to declare the \xa0 Nao \xa0 to Webots as in importable PROTO for the world we created. To proceed, click on the \xa0 IMPORTABLE EXTERNPROTO \xa0 button located at the top of the scene tree. \n The field editor, located below the scene tree, should display an \xa0 IMPORTABLE EXTERNPROTO \xa0 pane with a button named "Insert new". Click this button and select the \xa0 Nao \xa0 robot from the \xa0 PROTO nodes (Webots Projects) \xa0 section. Press the "Insert" button. If you hover the \xa0 Nao \xa0 item that appeared below the "Insert new" button, you will see in the tooltip the URL from where it is downloaded. Save the world file, so that this information is stored. \n Although not apparent, the scene tree is in fact a \xa0 Group \xa0 node, and each of the objects in the scene tree like \xa0 WorldInfo , \xa0 Viewpoint , \xa0 TexturedBackground \xa0 and so forth are nothing more than nodes defined as its children. We refer to this \xa0 Group \xa0 node containing everything as the \xa0 root \xa0 node. In order to insert the \xa0 Nao \xa0 robot, the reference we require is actually a reference to  the\xa0 children \xa0field of the\xa0 root \xa0node . In the spot marked by \xa0 CODE PLACEHOLDER 1 , the following code allows to get this reference. \n root_node = robot.getRoot()\nchildren_field = root_node.getField( \'children\' )\n \n To spawn a node you should use the supervisor function \xa0 importMFNodeFromString \xa0 or \xa0 importSFNodeFromString . The "MFNode" and "SFNode" components in the name of these functions specify what is the type of the node where the objects is inserted \xa0 into . "MFNode" stands for multi-field node whereas "sf_node" stands for single-field node. \n As previously mentioned, the \xa0 Nao \xa0 should be added to the \xa0 children \xa0 field of the \xa0 root \xa0 node, and as you might guess, this \xa0 children \xa0 field is of type multi-field. \n Let\'s add it from string after 20 time steps, add the following snippet in \xa0 CODE PLACEHOLDER 2 : \n if  i ==  20 :\n  children_field. importMFNodeFromString ( -1 ,  \'Nao { }\' )\n \n The "-1" specifies in which position we wish to insert the node, in this case, to insert it at the last position. \xa0 "Nao { }" \xa0 is a string that describes what we wish to spawn. The way the object is described is by using the VRML97 format, this is the format used in the world files as well. After 20 timesteps, the \xa0 Nao \xa0 robot will spawn in the middle of the scene. \n Let\'s assume we wanted the \xa0 Nao \xa0 to be spawned in the position BB-8 used to be, we certainly could move it there following the procedure of hands-on 2, but that would not be smart. In fact, we can simply specify the translation field directly in the string! Replace the string \xa0 "Nao { }" \xa0 with \xa0 "Nao { translation 2.5 0 0.334 }" \xa0 and it will spawn exactly at that location. It does not stop there, in the same fashion we could define its \xa0 controller \xa0 parameter, or the \xa0 cameraWidth \xa0 or any other of its parameters in the same fashion. \n \n \n \n Trick: \xa0 If you are not familiar with VRML97, an easy trick to define these strings is to let Webots do it for you. You can manually create the object (using the Webots interface), and then save the world. When saving, Webots will translate what you built into a string of text. If you open the world file with a text editor, you can simply copy the description of the object. \n \n Track Object Position Using a Supervisor \n Since the supervisor has unlimited power, it is the perfect tool to track the evolution of a simulation. In this section,  we will use the acquired knowledge to spawn a ball, and track its position as it falls and when it touches the ground change its color . \n \n \n Hands-on #4 : We need to use the \xa0 wb_supervisor_field_import_mf_node_from_string \xa0 function to spawn the ball at location \xa0 0 1 1 , and since we are at it, let us get a reference to this node and to the \xa0 color \xa0 field of the \xa0 Ball . But first, we have to declare the \xa0 Ball \xa0 as an \xa0 IMPORTABLE EXTERNPROTO \xa0 as we did it previously for the \xa0 Nao \xa0 robot. Once done, in \xa0 CODE PLACEHOLDER 1 \xa0 add: \n children_field.importMFNodeFromString( -1 ,  \'DEF BALL Ball { translation 0 1 1 }\' )\nball_node = robot.getFromDef( \'BALL\' )\ncolor_field = ball_node.getField( \'color\' )\n \n If you run the simulation, the ball should appear and begin to fall until it clashes with the ground. \n In order to track the position of the ball, we could get a reference to its translation field and read that value continuously however a simpler approach would be to use another supervisor method created for that task, namely \xa0 getPosition . In \xa0 CODE PLACEHOLDER 2 \xa0 add: \n position = ball_node.getPosition()\nprint( \'Ball position: %f %f %f\\n\'  %(position[ 0 ], position[ 1 ], position[ 2 ]))\n \n Now that we can track it, let\'s change the color of the bool as soon as it collides. Since the ball has a radius of 0.2, we can change the \xa0 color \xa0 field when the "Y" coordinate of the position is smaller than this value. \n if  position[ 2 ] <  0.2 :\n  red_color = [ 1 ,  0 ,  0 ]\n  color_field.setSFColor(red_color)\n \n \n \n Putting Everything Together \n Here you can find the complete code of the controller. \n from controller import Supervisor\n\nTIME_STEP = 32\n\nrobot = Supervisor()  # create Supervisor instance\n\n# [CODE PLACEHOLDER 1]\nbb8_node = robot.getFromDef(\'BB-8\')\ntranslation_field = bb8_node.getField(\'translation\')\n\nroot_node = robot.getRoot()\nchildren_field = root_node.getField(\'children\')\n\nchildren_field.importMFNodeFromString(-1, \'DEF BALL Ball { translation 0 1 1 }\')\nball_node = robot.getFromDef(\'BALL\')\ncolor_field = ball_node.getField(\'color\')\n\ni = 0\nwhile robot.step(TIME_STEP) != -1:\n  # [CODE PLACEHOLDER 2]\n  if (i == 0):\n    new_value = [2.5, 0, 0]\n    translation_field.setSFVec3f(new_value)\n\n  if i == 10:\n      bb8_node.remove()\n\n  if i == 20:\n    children_field.importMFNodeFromString(-1, \'Nao { }\')\n\n  position = ball_node.getPosition()\n  print(\'Ball position: %f %f %f\\n\' %(position[0], position[1], position[2]))\n\n  if position[2] < 0.2:\n    red_color = [1, 0, 0]\n    color_field.setSFColor(red_color)\n\n  i += 1 \n Conclusion \n With this tutorial you have learned: \n \n A \xa0 Supervisor \xa0 is nothing more than a \xa0 Robot \xa0 with extra powers, therefore anything that you can do with a \xa0 Robot \xa0 instance, you can do with a \xa0 Supervisor \xa0 instance. \n A \xa0 Supervisor \xa0 is not bound by physics, since its powers are unlimited, it can also "cheat". \n Whenever one wishes to alter the scene tree using a \xa0 Supervisor , a reference needs to be obtained:\n \n To insert a node, you need a reference of the field that will contain it. \n To remove a node, you need a reference to the node (i.e., the object) itself. \n To change the value of a parameter like (translation, color, size, etc.) you need a reference to said field. \n \n \n Spawning a robot or an object can be achieved by defining it as an \xa0 IMPORTABLE EXTERNPROTO \xa0 and using the \xa0 wb_supervisor_field_import_mf_node_from_string \xa0 API function. \n \n', 'tags': '', 'url': 'Tutorial8.html'}, {'title': 'Basketball', 'text': 'basketball_game_demo.7z \n 籃球遊戲場景的設置與得分感測 \n basketball.wbt \n #VRML_SIM R2023b utf8\n\nWorldInfo {\n  basicTimeStep 32\n}\n\nViewpoint {\n  orientation -0.577 0.577 0.577 2.094\n  position 0 1 3\n}\n\nFloor {\n  size 5 5\n}\n\n# Circular Loop\nTrack {\n  radius 1\n  height 0.1\n  thickness 0.1\n  color 0.8 0.8 0.8\n}\n\n# Balls\nDEF BALL1 Solid {\n  translation 0.5 0.1 0\n  children [\n    Shape {\n      appearance Appearance {\n        material Material {\n          diffuseColor 1 0 0\n        }\n      }\n      geometry Sphere {\n        radius 0.05\n      }\n    }\n  ]\n  physics Physics {\n    density 1000\n  }\n}\n\nDEF BALL2 Solid {\n  translation -0.5 0.1 0\n  children [\n    Shape {\n      appearance Appearance {\n        material Material {\n          diffuseColor 0 0 1\n        }\n      }\n      geometry Sphere {\n        radius 0.05\n      }\n    }\n  ]\n  physics Physics {\n    density 1000\n  }\n}\n\n# Distance Sensor\nDEF DISTANCE_SENSOR DistanceSensor {\n  translation 0 0.1 1\n  rotation 0 1 0 1.5708\n  type "infra-red"\n} \n controller script: \n from controller import Robot\n\n# Time step of the simulation\nTIME_STEP = 32\n\n# Create the Robot instance\nrobot = Robot()\n\n# Get the distance sensor\ndistance_sensor = robot.getDevice(\'DISTANCE_SENSOR\')\ndistance_sensor.enable(TIME_STEP)\n\n# Counter for balls\nball_count = 0\nthreshold = 0.1  # Adjust based on your sensor\'s distance range\n\nwhile robot.step(TIME_STEP) != -1:\n    # Read the sensor value\n    sensor_value = distance_sensor.getValue()\n    \n    # Check if a ball is detected\n    if sensor_value < threshold:\n        ball_count += 1\n        print(f"Ball count: {ball_count}")\n        \n        # Wait until the ball passes\n        while distance_sensor.getValue() < threshold:\n            robot.step(TIME_STEP) \n 距離感測與接觸感測的差異: \n DistanceSensor \n \n Functionality : Measures the distance to an object in front of it. \n Type : Can be an infra-red, laser, ultrasonic, or other types of distance measuring sensors. \n Range : Can measure distances within a specified range, typically from a few centimeters to several meters. \n Use Case : Ideal for detecting objects at a distance, obstacle avoidance, measuring distances, and mapping environments. \n \n TouchSensor \n \n Functionality : Detects physical contact or touch. \n Type : Can be a bumper, force sensor, or force3D sensor. \n Range : Detects contact at a specific point or over an area. \n Use Case : Ideal for detecting collisions, pressure, and touch. Commonly used for bumpers on robots, detecting when a robot has touched or collided with an object. \n \n Example of Usage: \n DistanceSensor \n 設置: \n #VRML_SIM R2023b utf8\n\nWorldInfo {\n  basicTimeStep 32\n}\n\nViewpoint {\n  position 0 1 3\n}\n\nRobot {\n  controller "distance_sensor_controller"\n  \n  DistanceSensor {\n    name "distance_sensor"\n    type "infra-red"\n    translation 0 0.1 0.2\n  }\n} \n 控制程式: \n from controller import Robot\n\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\n\ndistance_sensor = robot.getDevice(\'distance_sensor\')\ndistance_sensor.enable(timestep)\n\nwhile robot.step(timestep) != -1:\n    distance = distance_sensor.getValue()\n    print(f"Distance: {distance}") \n TouchSensor \n 設置: \n #VRML_SIM R2023b utf8\n\nWorldInfo {\n  basicTimeStep 32\n}\n\nViewpoint {\n  position 0 1 3\n}\n\nRobot {\n  controller "touch_sensor_controller"\n  \n  TouchSensor {\n    name "touch_sensor"\n    type "bumper"\n    translation 0 0.1 0.2\n  }\n} \n 控制程式: \n from controller import Robot\n\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\n\ntouch_sensor = robot.getDevice(\'touch_sensor\')\ntouch_sensor.enable(timestep)\n\nwhile robot.step(timestep) != -1:\n    touched = touch_sensor.getValue()\n    if touched:\n        print("Touch detected!") \n 最後, 利用 touchsensor 與 display 顯示籃球進框得分: \n 場景設置: \n #VRML_SIM R2023b utf8\n\nWorldInfo {\n  basicTimeStep 32\n}\n\nViewpoint {\n  orientation -0.577 0.577 0.577 2.094\n  position 0 1 3\n}\n\nFloor {\n  size 5 5\n}\n\n# Circular Loop for the basketball hoop\nTrack {\n  radius 0.5\n  height 0.05\n  thickness 0.05\n  color 0.8 0.8 0.8\n  translation 0 1 0\n  rotation 1 0 0 1.5708\n}\n\n# Basketball\nDEF BASKETBALL Solid {\n  translation 0 1.2 0\n  children [\n    Shape {\n      appearance Appearance {\n        material Material {\n          diffuseColor 1 0.5 0\n        }\n      }\n      geometry Sphere {\n        radius 0.1\n      }\n    }\n  ]\n  physics Physics {\n    density 1\n  }\n}\n\n# Touch Sensor to detect the basketball passing through the hoop\nDEF TOUCH_SENSOR TouchSensor {\n  translation 0 1 0\n  rotation 1 0 0 1.5708\n  type "force"\n}\n\n# Display node to show the score\nDEF SCORE_DISPLAY Display {\n  width 64\n  height 64\n  translation 0 2 0\n} \n 控制程式: \n from controller import Robot, Display, TouchSensor\n\n# Create the Robot instance\nrobot = Robot()\n\n# Get the time step of the current world\ntimestep = int(robot.getBasicTimeStep())\n\n# Get the touch sensor and enable it\ntouch_sensor = robot.getDevice(\'TOUCH_SENSOR\')\ntouch_sensor.enable(timestep)\n\n# Get the display node\ndisplay = robot.getDevice(\'SCORE_DISPLAY\')\n\n# Initialize the score\nscore = 0\n\n# Function to update the display with the current score\ndef update_display(score):\n    display.setAlpha(1.0)\n    display.setColor(0x000000)\n    display.fillRectangle(0, 0, display.getWidth(), display.getHeight())\n    display.setAlpha(1.0)\n    display.setColor(0xFFFFFF)\n    display.setFont("Arial", 24, True)\n    display.drawText(f"Score: {score}", 10, 10)\n\n# Main loop\nwhile robot.step(timestep) != -1:\n    # Check if the touch sensor is pressed\n    if touch_sensor.getValue() > 0:\n        score += 1\n        update_display(score)\n        \n        # Wait until the ball passes\n        while touch_sensor.getValue() > 0:\n            robot.step(timestep) \n 若需要籃球投出後, 動用 supervisor 控制模式, 在原投球位置產生新球, 則使用下列場景與控制程式: \n 設置: \n #VRML_SIM R2023b utf8\n\nWorldInfo {\n  basicTimeStep 32\n}\n\nViewpoint {\n  orientation -0.577 0.577 0.577 2.094\n  position 0 1 3\n}\n\nFloor {\n  size 5 5\n}\n\n# Circular Loop for the basketball hoop\nTrack {\n  radius 0.5\n  height 0.05\n  thickness 0.05\n  color 0.8 0.8 0.8\n  translation 0 1 0\n  rotation 1 0 0 1.5708\n}\n\n# Initial Basketball\nDEF BASKETBALL Solid {\n  translation 0 1.2 0\n  children [\n    Shape {\n      appearance Appearance {\n        material Material {\n          diffuseColor 1 0.5 0\n        }\n      }\n      geometry Sphere {\n        radius 0.1\n      }\n    }\n  ]\n  physics Physics {\n    density 1\n  }\n}\n\n# Touch Sensor to detect the basketball passing through the hoop\nDEF TOUCH_SENSOR TouchSensor {\n  translation 0 1 0\n  rotation 1 0 0 1.5708\n  type "force"\n}\n\n# Display node to show the score\nDEF SCORE_DISPLAY Display {\n  width 64\n  height 64\n  translation 0 2 0\n} \n 控制程式: \n from controller import Supervisor\n\n# Create the Supervisor instance\nsupervisor = Supervisor()\n\n# Get the time step of the current world\ntimestep = int(supervisor.getBasicTimeStep())\n\n# Get the touch sensor and enable it\ntouch_sensor = supervisor.getDevice(\'TOUCH_SENSOR\')\ntouch_sensor.enable(timestep)\n\n# Get the display node\ndisplay = supervisor.getDevice(\'SCORE_DISPLAY\')\n\n# Get the basketball node\nbasketball = supervisor.getFromDef(\'BASKETBALL\')\n\n# Initialize the score\nscore = 0\n\n# Function to update the display with the current score\ndef update_display(score):\n    display.setAlpha(1.0)\n    display.setColor(0x000000)\n    display.fillRectangle(0, 0, display.getWidth(), display.getHeight())\n    display.setAlpha(1.0)\n    display.setColor(0xFFFFFF)\n    display.setFont("Arial", 24, True)\n    display.drawText(f"Score: {score}", 10, 10)\n\n# Main loop\nwhile supervisor.step(timestep) != -1:\n    # Check if the touch sensor is pressed\n    if touch_sensor.getValue() > 0:\n        score += 1\n        update_display(score)\n        \n        # Get the position of the current basketball\n        ball_position = basketball.getPosition()\n        \n        # Remove the old basketball\n        basketball.remove()\n\n        # Create a new basketball at the position of the old one\n        new_ball = supervisor.getFromDef(\'BASKETBALL\')\n        new_ball_node = new_ball.clone()\n        new_ball_node.getField(\'translation\').setSFVec3f(ball_position)\n\n        # Wait until the ball passes\n        while touch_sensor.getValue() > 0:\n            supervisor.step(timestep) \n 其他相關內容: \n Webots 參考手冊 : \n This manual contains the specification of the nodes and fields of the ".wbt" world description language used in Webots. It also specifies the functions available to operate on these nodes from controller programs. \n The Webots nodes and APIs are open specifications which can be freely reused without authorization from Cyberbotics. The Webots API can be freely ported and adapted to operate on any robotics platform using the remote-control and/or the cross-compilation frameworks. Cyberbotics offers support to help developers implementing the Webots API on real robots. This benefits to the robotics community by improving interoperability between different robotics applications. \n 本手冊包含了 Webots 中使用的 ".wbt" 世界描述語言的節點和欄位規範。它還規範了從控制器程序操作這些節點所使用的功能。 \n Webots 節點和 API 是開放規範，可以自由重複使用，無需 Cyberbotics 授權。Webots API 可以自由移植並適應於任何機器人平台，使用遠端控制和/或交叉編譯框架。Cyberbotics 提供支持，幫助開發者在實際機器人上實現 Webots API。這將有助於機器人社群，提升不同機器人應用之間的互操作性。 \n 節點與函式:  https://www.cyberbotics.com/doc/reference/nodes-and-functions \n https://cyberbotics.com/doc/reference/contactproperties \n', 'tags': '', 'url': 'Basketball.html'}, {'title': 'counter', 'text': 'Webots 啟動時，同時啟動串流伺服器指令: webotsw --stream \n 內建埠號為 1234，由於採用 WebGL2 進行網頁著色，因此在 Windows 環境中使用 Edge 連線至  http://localhost:1234 \xa0或  http://stream_server_ip:1234  將會較為順暢. \n 至於希望利用 display 展示投籃成績的方法，僅能在近端 Webots 套件中檢視，因此若要讓記分板或計時器能在串流瀏覽器中展示，必須採用 7 段顯示器設置，並利用 supervisor 模式進行操控. \n 利用 Solvespace 繪製的 7 段顯示器零組件檔案:\xa0 score_counter.7z \n 若要在 Webots 中利用變顏色的 .obj 零件顯示數字, 可以透過 Solid - Shape - Mesh 然後將 url 指向 7 段顯示器中的 a ~ g 零件, 並且利用 controller 改變各零件的顏色. \n 利用 r, b, y, g 按鍵改變 7 段顯示器中的 f 零件示範場景:\xa0 7_segment_display.7z , 執行結果如下: \n \n three_digit_counter.7z \n 由外部 Python 程式的執行控制 Webots 場景: \n \n 場景 Robot 的 Controller 欄位設為 extern \n 可攜程式環境的 PYTHONPATH 環境變數必須納入 Webots 中的 Python 程式庫: set PYTHONPATH=%Disk%:\\Python313\\DLLs;%Disk%:\\Python313\\Lib;%Disk%:\\Python313\\Lib\\site-packages;%Disk%:\\Webots_2025a\\msys64\\mingw64\\bin;%Disk%:\\Webots_2025a\\lib\\controller\\python; \n 可攜系統的 PYTHON_PATH 必須指向所使用的 Python 版本目錄: set PYTHON_PATH=%Disk%:\\Python313 \n 可攜系統的 WEBOTS_HOME 必須指令 Webots 所在目錄: set WEBOTS_HOME=%Disk%:\\Webots_2025a \n \n 原生的 Webots Controller 若根據上述說明, 由外部的 Python 程式控制後, 再經由程式啟動模擬, 應該可以透過 Websocket 設置 Webots 應用程式所在電腦作為 Server, 與網路上的另一台 Client 程式進行互動. \n 以下先測試由外部程式啟動模擬並進行倒數 999 秒: \n from controller import Supervisor\n\nclass SevenSegmentController:\n    def __init__(self, supervisor, color_on, color_off):\n        self.supervisor = supervisor\n\n        # Define the segments for each digit\n        self.digit_segments = [\n            [f"a1", f"b1", f"c1", f"d1", f"e1", f"f1", f"g1"],  # Units\n            [f"a2", f"b2", f"c2", f"d2", f"e2", f"f2", f"g2"],  # Tens\n            [f"a3", f"b3", f"c3", f"d3", f"e3", f"f3", f"g3"]   # Hundreds\n        ]\n\n        # Segment patterns for digits 0-9\n        self.segment_patterns = {\n            0: [1, 1, 1, 1, 1, 1, 0],\n            1: [0, 1, 1, 0, 0, 0, 0],\n            2: [1, 1, 0, 1, 1, 0, 1],\n            3: [1, 1, 1, 1, 0, 0, 1],\n            4: [0, 1, 1, 0, 0, 1, 1],\n            5: [1, 0, 1, 1, 0, 1, 1],\n            6: [1, 0, 1, 1, 1, 1, 1],\n            7: [1, 1, 1, 0, 0, 0, 0],\n            8: [1, 1, 1, 1, 1, 1, 1],\n            9: [1, 1, 1, 1, 0, 1, 1]\n        }\n\n        # Colors for on and off states\n        self.color_on = color_on  # Bright green\n        self.color_off = color_off  # Black\n\n        # Retrieve material nodes for each segment\n        self.segment_nodes = []\n        for digit in self.digit_segments:\n            digit_nodes = []\n            for segment in digit:\n                node = self.supervisor.getFromDef(segment)\n                if node is None:\n                    print(f"Error: Node with DEF name \'{segment}\' not found!")\n                    exit()\n                digit_nodes.append(node.getField("diffuseColor"))\n            self.segment_nodes.append(digit_nodes)\n\n    def set_digit(self, digit_index, value):\n        """Set the digit at the given index (0 for units, 1 for tens, 2 for hundreds) to the given value (0-9)."""\n        pattern = self.segment_patterns[value]\n        for i, state in enumerate(pattern):\n            color = self.color_on if state else self.color_off\n            self.segment_nodes[digit_index][i].setSFVec3f(color)\n\n    def display_number(self, number):\n        """Display a number (0-999) using the three 7-segment displays."""\n        if not (0 <= number <= 999):\n            print("Error: Number out of range (must be 0-999)")\n            return\n\n        # Break the number into hundreds, tens, and units\n        hundreds = number // 100\n        tens = (number % 100) // 10\n        units = number % 10\n\n        # Update the displays\n        self.set_digit(2, hundreds)\n        self.set_digit(1, tens)\n        self.set_digit(0, units)\n\n\n# Main program\nif __name__ == "__main__":\n    # Create a Supervisor instance\n    supervisor = Supervisor()\n\n    # 設定模擬模式為實時啟動\n    supervisor.simulationSetMode(Supervisor.SIMULATION_MODE_REAL_TIME)\n\n\n    # Define colors\n    color_on = [0.0, 1.0, 0.0]  # Bright green\n    color_off = [0.0, 0.0, 0.0]  # Black\n\n    # Create an instance of the SevenSegmentController\n    controller = SevenSegmentController(supervisor, color_on, color_off)\n\n    # Run the simulation loop\n    timestep = int(supervisor.getBasicTimeStep())\n    timer = 999  # Start countdown from 999\n\n    while supervisor.step(timestep) != -1:\n        if timer >= 0:  # Continue counting down until 0\n            controller.display_number(timer)\n            timer -= 1  # Decrement the timer\n        supervisor.step(1000)  # Wait for 1 second in simulation time \n 其中由程式啟動模擬的程式段為: \n # Create a Supervisor instance\nsupervisor = Supervisor()\n\n# 設定模擬模式為實時啟動\nsupervisor.simulationSetMode(Supervisor.SIMULATION_MODE_REAL_TIME) \n 範例如下:\xa0 three_digit_counter_w9.7z \n', 'tags': '', 'url': 'counter.html'}, {'title': 'Youbot_cart', 'text': '\n youbot_cart.7z \n https://webots.cloud/proto \xa0 \n https://seamonsters-2605.github.io/archive/mecanum/ \xa0 \n 座標系統:\xa0 https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates \xa0 \n ENU 與 NED \n In many targeting and tracking applications the local East, North, Up (ENU) Cartesian coordinate system is far more intuitive and practical than ECEF or Geodetic coordinates. The local ENU coordinates are formed from a plane tangent to the Earth\'s surface fixed to a specific location and hence it is sometimes known as a "Local Tangent" or "local geodetic" plane. By convention the east axis is labeled x, the north y and the up z.\xa0 \n In an airplane, most objects of interest are below the aircraft, so it is sensible to define down as a positive number. The North, East, Down (NED) coordinates allow this as an alternative to the ENU. By convention, the north axis is labeled x ′, the east y ′ and the down z ′. This ensures NED coordinates to be right handed, as ENU coordinates are. \n The origin of this coordinate system is usually chosen to be a fixed point on the surface of the geoid below the aircraft\'s center of gravity. When that is the case, the coordinate system is sometimes referred as a "local-North-East-Down Coordinate System". \n Mecanum Wheels: \n \n \n \n figures taken from\xa0 http://km.emotors.ncku.edu.tw/emotor/worklog/EMTRC_wordpress/?p=593 \xa0 \n References: \n https://www.ezb2b.com/pdfimages/2024pdf_7893_5767707_2853122_0824.pdf \xa0', 'tags': '', 'url': 'Youbot_cart.html'}, {'title': 'Homework', 'text': '作業 (30%) \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n part1: \n 請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n 備註:\xa0 請更新上列 portable_wcm2025.7z 中的 wscite 為 5.5.5 版 ( wscite_5.5.5.7z , 解開壓縮檔案後取代 5.5.4 版的 wscite 目錄) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n Blender4.2.7z \n part2: \n 請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景. \n base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec. \n part3: \n 模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停. \n 參考資料: \n cd2025_hw1_demo.7z \n Analysis of Simple Planar Linkages.pdf \n \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景. \n 參考資料: \n fourbar_slvs.7z \n \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 ( 參考影片 )後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統. \n 參考資料: \n 參考資料: \n fourbar_ball_throwing_linkage.slvs \n sixbar_ball_throwing_linkage.slvs \n \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': 'HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號 \n \n cd2025_hw1_demo.7z \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': 'HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號 \n \n fourbar_slvs.7z \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': 'HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號 \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Exam', 'text': 'Exam1 (10%):  建立 Webots 基本物件模擬場景 (HW1 內容之延伸應用測驗) \n 各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam2 (10%):  利用 CAD 零組件建立模擬場景 (HW2 內容之延伸應用測驗) \n 各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam3 (20%):  Webots 機電模擬場景的協同設計 (HW3 內容之延伸應用測驗) \n 各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站. \n 協同分組方式: \n \n 分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁. \n \n', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 (HW1 內容之延伸應用測驗) \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號 \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': 'Exam2 (10%): 利用 CAD 零組件建立模擬場景 (HW2 內容之延伸應用測驗) \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號 \n', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3 (20%): Webots 機電模擬場景的協同設計 (HW3 內容之延伸應用測驗) \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號 \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Reference', 'text': '以下相關參考資料, 部分網站連結只能從系上 IPv6 網段中擷取: \n \n', 'tags': '', 'url': 'Reference.html'}, {'title': 'Webots', 'text': '\n https://www.theconstruct.ai/webots-robot-simulator-ros-olivier-michel/  ( Old talk ,  Video1 ,  Video2 ,  Video3 ) \n \n 由外部 Python 程式的執行控制 Webots 場景: \n \n 場景 Robot 的 Controller 欄位設為 extern \n 可攜程式環境的 PYTHONPATH 環境變數必須納入 Webots 中的 Python 程式庫: set PYTHONPATH=%Disk%:\\Python313\\DLLs;%Disk%:\\Python313\\Lib;%Disk%:\\Python313\\Lib\\site-packages;%Disk%:\\Webots_2025a\\msys64\\mingw64\\bin;%Disk%:\\Webots_2025a\\lib\\controller\\python; \n 可攜系統的 PYTHON_PATH 必須指向所使用的 Python 版本目錄: set PYTHON_PATH=%Disk%:\\Python313 \n 可攜系統的 WEBOTS_HOME 必須指令 Webots 所在目錄: set WEBOTS_HOME=%Disk%:\\Webots_2025a \n \n extern 相關說明 \n Python controller programming \n supervisor \n \n https://mde.tw/content/Webots%20Doc.html \n Webots assets 儲存目錄 (容量約 831MB, 若包括 Webots 2025a 1GB, 整個系統約佔 2GB): \n 在 Windows 操作系統開啟 webotsw.exe: \n C:\\Users\\%USERNAME%\\AppData\\Local\\Cyberbotics\\Webots\\cache\\assets \n 在可攜程式環境中開啟 webotsw.exe: \n Y:\\home_ipv6\\AppData\\Local\\Cyberbotics\\Webots\\cache\\assets \n Stable version: \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB) \n 1.  與  python_2025_lite.7z  結合使用, Webots - Tools - Preferences - Python Command 設定為 Y:\\Python310\\python.exe \n 2.  start_ipv6.bat 必須設定: \n REM for Webots\nset PYTHON_PATH=%Disk%:\\Python310\n\nREM for Webots\nset  path_webots=%Disk%:\\Webots_2025a\\msys64\\mingw64\\bin\n\nREM 在 path 納入 %path_webots%\npath=~~;%path_webots%;%path%; \n 3.  pip install opencv-python \n 配置完成後, 測試 Python 是否設定正確:  Webots_examples.zip \xa0( source ) \n vrml97specification.pdf  ( VRML 2.0 ,  VRML ) \n https://github.com/Introduction-to-Autonomous-Robots/Introduction-to-Autonomous-Robots \n Webots 原始碼:  https://github.com/cyberbotics/webots \n 官方網站:  https://cyberbotics.com/ \n https://webots.cloud/ \n https://www.cyberbotics.com/doc/guide/samples-howto?version=cyberbotics:R2023b \n https://www.cyberbotics.com/doc/guide/index.php?version=cyberbotics:R2019a \n License:  https://cyberbotics.com/doc/guide/webots-license-agreement \n https://cyberbotics.com/doc/guide/web-interface  (無法使用 Firefox 觀看) \n https://cyberbotics.com/doc/guide/web-server  ( Github ) \n https://cyberbotics.com/doc/guide/web-streaming  ( Command Line Arguments ) (無法使用 Firefox 觀看) \n webotsw --stream \n 使用 Edge 連線到 http://localhost:1234/index.html \n https://cyberbotics.com/doc/guide/interfacing-webots-to-third-party-software-with-tcp-ip \n https://felipenmartins.github.io/Robotics-Simulation-Labs/ \n \n Webots_ex \n Webots 最新版可直接從  https://github.com/cyberbotics/webots/releases  下載. \n Stable version:  Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB) \n 使用授權:  https://cyberbotics.com/doc/guide/webots-license-agreement \n Webots Source Code Webots is released under the terms of the Apache 2.0 license agreement. Apache 2.0 is a industry friendly, non-contaminating, permissive open source license that grants everyone the right to use a software source code, free of charge,  for any purpose, including commercial applications . \n Webots Sample Simulations \n Webots sample simulations include world files, robot and object models, robot controllers, plugins, libraries, etc. Generally, all the sample simulations source files distributed with Webots have a license header referring to the Apache 2.0 license, except for a few robot and object assets (proto files) which are distributed under the terms of the open source Webots Assets license agreement and a few sample simulations which were contributed by users under various license agreements, mostly open source ones. In any case, the license agreement is explicitly included in the corresponding files and/or folders. \n Webots 原始碼 \n Webots 是根據 Apache 2.0 授權協議發布的。Apache 2.0 是一個對產業友善、非強制衍生性的寬鬆開源授權，讓所有人都有權利免費使用軟體原始碼， 可用於任何目的，包括商業應用 。 \n Webots 範例模擬 \n Webots 範例模擬包含場景檔案、機器人和物件模型、機器人控制器、外掛程式、程式庫等。一般來說，所有隨 Webots 發布的範例模擬原始檔都有引用 Apache 2.0 授權的授權標頭，但有少數機器人和物件資產（proto 檔案）是根據開源的 Webots Assets 授權協議發布，還有一些由使用者貢獻的範例模擬則是根據各種授權協議發布，大多是開源授權。無論如何，相關授權協議都明確包含在對應的檔案和/或資料夾中。 \n \n https://github.com/cyberbotics/webots/tree/released/resources/translations  中並沒有繁體中文翻譯, 但建議使用英文版即可. \n 自行編譯 Webots 導引:  https://github.com/cyberbotics/webots/wiki \n 自行建立網際模擬伺服器導引:  https://cyberbotics.com/doc/guide/web-server \n \n 操作教學:  https://cyberbotics.com/doc/guide/tutorials \n 導入 STL 模型:  https://cyberbotics.com/doc/reference/mesh \n 使用 C 執行控制:  https://cyberbotics.com/doc/guide/using-c \n 使用 Python 執行控制:  https://cyberbotics.com/doc/guide/using-python \n \n References: \n https://felipenmartins.github.io/Robotics-Simulation-Labs/ \u3000 \n https://courses.ideate.cmu.edu/16-375/f2022/ref/text/resources/Webots.html \n https://courses.ideate.cmu.edu/16-375/f2024/text/simulations/index.html \n https://www.bx.psu.edu/~thanh/naoqi/software/webots/webots_index.html \n https://uclalemur.com/ \n https://www.cs.csubak.edu/~wli/Wei_Li_Tch/CS_456/456_LAB/Guide.pdf \xa0 \n https://www.udemy.com/course/learn-mobile-robotics-with-webots \n https://robmosys.eu/ \n https://opendr.eu/robotic-simulations-on-the-web-education-dissemination-and-competition-organization/ \n https://www.innovationplace.eu/project/open-source-3d-robot-simulator-with-web-interface-helps-industries-to-implement-digital-twin-models/2957 \n A Swiss company developed a realistic robot simulator which can be used to simulate various digital twin scenarios involving mobile robots, robotics arms, drones, autonomous vehicles, industrial processes, etc. Sensors and actuators can be modeled, such as cameras, lidars, laser range-finder, etc. Robots are controlled by intelligent programs processing sensor data with AI algorithms. The software is fully open-source, runs on the desktop and features a cloud-based 3D web interface. \n 這家瑞士公司開發了一款逼真的機器人模擬器，可用於模擬包括移動機器人、機械手臂、無人機、自動駕駛車輛、工業製程等各種數位分身的情境。此模擬器可以模擬各種感測器和致動器，例如攝影機、光達、雷射測距儀等。機器人由智慧程式控制，透過人工智慧演算法處理感測器數據。這款軟體完全開源，可在桌面電腦上執行，並提供基於雲端的 3D 網頁介面。 \n 這家中小企業開發的 Webots 軟體是一款開源且跨平台的桌面應用程式，用於模擬機器人。它提供完整的開發環境，可用於建模、程式設計和模擬機器人。該軟體專為專業用途設計，在工業、教育和研究領域被廣泛使用。自 1998 年以來，這家中小企業持續將 Webots 作為其主要產品進行維護。該軟體最初是在瑞士洛桑聯邦理工學院（EPFL）開發的。 \n Webots 可用於建立機器人原型、開發、測試和驗證人工智慧和控制演算法、教授學生機器人學等。使用者可以利用豐富的 Webots 資產庫（包含機器人、感測器、致動器、物件和材質）輕鬆設計完整的機器人模擬。軟體支援匯入現有的 CAD 模型（來自 Blender 或通用機器人描述格式 URDF）以及 OpenStreetMap 地圖。現代化的圖形使用者介面讓使用者可以編輯他們的模擬和機器人控制器，節省機器人專案開發時間。 \n 使用者可以建立各種類型的模擬，包括雙輪桌面機器人、工業機械臂、雙足機器人、多足機器人、模組化機器人、汽車、飛行無人機、水下自主載具、履帶式機器人、航太載具等。他們可以設置室內或室外的互動環境。這些數位分身模型可用於建立對應實體系統的虛擬原型，並在模擬中測試各種改進。如果模擬中測試的改進顯示出效益，就可以實作到實體系統中。數位分身原型方法提供多項優勢，包括更好的系統功能溝通、更快速且更經濟的系統改進探索，以及包含持續整合的更有效率開發工作流程。 \n Webots 的核心是基於現代圖形使用者介面（基於 Qt 函式庫）、物理引擎（基於開放動力學引擎 ODE 的分支版本）和基於 OpenGL 3.3 函式庫的 3D 渲染引擎的組合。它可在 Windows、Linux 和 macOS 上執行。Webots 模擬可匯出為影片、互動式 HTML 場景或動畫，甚至可以 3D 形式串流至網頁。機器人可以使用簡單的 API 以不同程式語言進行程式設計，如 C、C++、Python、Java、MATLAB 或 ROS，涵蓋所有基本的機器人需求。Webots 提供網頁介面（展示於 https://webots.cloud），可在雲端執行模擬、播放 3D 動畫，以及展示場景和物件。 \n 透過這家中小企業開發的工具，使用者可以： \n 1. 受惠於高品質的免費開源技術來模擬機器人系統。 \n 2. 輕鬆將模擬、3D 動畫和 3D 模型匯出至網頁，以便與同事、合作夥伴、客戶和大眾分享。 \n 3. 受惠於這家瑞士中小企業的專業知識，該企業積極支援 Webots 軟體，並為客戶提供顧問諮詢和客製化開發服務。 \n 4. 善用 Webots 使用者社群的貢獻，社群會分享機器人、感測器、致動器、物件、環境、基準測試、控制器程式等模型。 \n 5. 可以透過 https://webots.cloud/competition 輕鬆舉辦機器人挑戰賽和程式設計競賽。 \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Webots_ref', 'text': 'https://www.cyberbotics.com/doc/reference/node-chart?version=cyberbotics:R2023b \n Tutorial Video 1 \n Tutorial Video 2 \n https://robotics.stackexchange.com/search?q=webots \n https://cyberbotics.com/doc/guide/tutorial-1-your-first-simulation-in-webots \n https://cyberbotics.com/doc/guide/sample-webots-applications \n https://webots.cloud/competition \n https://felipenmartins.github.io/Robotics-Simulation-Labs/ \n https://www.instructables.com/Vacuum-Cleaner-Robot-in-Webots/ \n https://medium.com/@albert.brucelee/introduction-to-webots-robot-simulator-and-e-puck-robot-8a2e2b5d22a9 \n https://ardupilot.org/dev/docs/sitl-with-webots.html \n https://www.cyberbotics.com/doc/guide/tinkerbots?version=R2019a \n https://www.cyberbotics.com/doc/discord/technical-questions?version=master \n https://www.cyberbotics.com/doc/discord/development?version=master \n https://youtu.be/gyAVOrX_IMk?si=MZQ8uQg1Ns1UxdCb \n https://www.youtube.com/watch?v=bfsJFwryga4 \n', 'tags': '', 'url': 'Webots_ref.html'}, {'title': 'Webots_doc', 'text': 'Examples:  https://courses.ideate.cmu.edu/16-375/f2024/text/simulations/index.html \n Webots_examples.7z \n Video \n Samples \n Group \n Pose  (translation and rotation) \n Transform  (scale) \n Shape \n CadShape  (url of obj) \n Solid \n Robot  (controller,  controller programming ) \n \n \n', 'tags': '', 'url': 'Webots_doc.html'}, {'title': 'Nodes', 'text': 'SoildReference \n SolidReference 可以用在 Joint 節點的 endPoint 欄位中，用來指向一個現有的 Solid 或靜態環境 <static environment>。通過這種方式，可以閉合機械迴圈。 \n 當指向一個 Solid 時，唯一的限制是 Solid 和 Joint 必須是某個共同上層 Solid 的後代。 SolidReference 是一個引用類型，允許在 Joint 節點的 endPoint 欄位中指定某個目標。它可以指向兩種類型的對象： \n 現有的 Solid：這是一個具體的實體（例如某個機械零件或組件）。 \n 靜態環境 <static environment>：這通常指的是不動的參考框架（例如地面或固定基座）。 \n 用法： \n 在模擬或設計中，當需要定義一個關節（Joint）的連接點時，SolidReference 提供了一個靈活的方式來指定這個點是連接到某個具體的實體還是靜態的外部環境。 \n 例如，在一個機械手臂的模擬中，SolidReference 可以用來指定手臂的某個關節是連接到另一個手臂部件（Solid）還是固定在地面上（靜態環境 <static environment>）。 \n endPoint 欄位的用途 \n endPoint 是 Joint 節點的一個屬性，用來定義關節的終點（或連接點）。 \n 通過在 endPoint 中使用 SolidReference，系統能夠明確知道這個關節連接到哪個對象。 \n 用法示例： \n 假設你正在設計一個雙擺系統（兩個連桿通過關節連接），第一個關節的 endPoint 可能會指向第一個連桿（Solid），而第二個關節的 endPoint 可能指向第二個連桿或固定基座（靜態環境）。 \n 閉合機械迴圈（Mechanical loops） \n 機械迴圈 是指在機械結構中，部件通過關節形成一個閉合的鏈，例如四連桿機構或某些並聯機器人結 \n SolidReference 的重要性在於它允許系統正確處理這樣的閉合結構。 \n 如何實現： \n 通過在 Joint 的 endPoint 中使用 SolidReference，可以將一個關節的終點連接到某個已存在的 Solid，從而形成閉合迴圈。 \n 例如，在一個四連桿機構中，每個關節的 endPoint 會指向下一個連桿，直到最後一個關節的 endPoint 連回到第一個連桿，形成閉合。 \n 為什麼需要閉合迴圈： \n 在模擬中，閉合迴圈確保了機械系統的運動學和動力學約束能夠被正確解析，例如計算各部件的相對運動或力。 \n 指向 Solid 時的限制 \n 限制條件：當 SolidReference 用來指向一個 Solid 時，這個 Solid 和 Joint 必須是某個共同上層 Solid 的後代。 \n 解釋： \n 這意味著 Solid 和 Joint 必須在同一個層次結構（hierarchy）內，且共享一個共同的「祖先」 Solid。 \n 這種限制確保了系統能夠在一個明確的參考框架內解析關節和實體之間的關係，避免模擬中的歧義或錯誤。 \n 示例： \n 假設有一個機械系統，包含一個主框架（上層 Solid），這個主框架下有兩個子部件（兩個 Solid）和一個關節（Joint）。如果想讓這個關節連接到其中一個子部件，則這個子部件和關節必須都在主框架的層次結構內。 \n 如果試圖讓關節連接到一個完全獨立的 Solid（不在主框架的後代中），系統可能會因為無法確定相對位置或運動關係而報錯。 \n 實際應用場景 \n 機器人模擬：在模擬多關節機器人時，SolidReference 可以用來定義每個關節的連接點，確保手臂或腿部的運動符合設計。 \n 汽車懸吊系統：懸吊系統中的連桿和關節可能形成閉合迴圈，SolidReference 幫助模擬這些部件如何相互作用。 \n 遊戲引擎物理模擬：在物理引擎（如 Unity 或 Unreal Engine）中，類似的概念用來定義剛體（Solid）和關節（Joint）之間的關係。 \n 注意事項 \n 層次結構的重要性：在使用 SolidReference 時，必須確保系統的層次結構設計合理，否則可能違反「共同上層 Solid」的限制。 \n 靜態環境的特殊性：當 SolidReference 指向靜態環境時，通常不需要考慮層次結構，因為靜態環境是一個全局參考框架。 \n 模擬效率：正確使用 SolidReference 可以減少模擬中的計算錯誤，提高系統的穩定性和效率。 \n ContactProperties \n 在 Webots 中，ContactProperties 節點用來定義兩個物體之間的接觸屬性（例如摩擦力、反彈係數等）。這對於模擬物理互動（例如碰撞、滑動或滾動）非常重要。 \n 基本結構 ContactProperties 是一種物理屬性節點，用於描述材料之間的接觸行為。它需要放置在 WorldInfo.physics 節點中，並且適用於場景中的物體。 \n ContactProperties {\n  material1 "Material1"\n  material2 "Material2"\n  coulombFriction 0.5\n  bounce 0.2\n  bounceVelocity 0.1\n  softERP 0.2\n  softCFM 0.01\n} \n 屬性解釋 \xa0\xa0\xa0 material1 和 material2 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 定義接觸的兩個物體的材料。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 如果 material1 或 material2 是空字串（""），則表示這些屬性適用於所有材料。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 例如，material1 "wood" 和 material2 "metal" 定義木材和金屬之間的接觸行為。 \xa0\xa0\xa0 coulombFriction \xa0\xa0\xa0\xa0\xa0\xa0\xa0 定義庫倫摩擦係數，用於模擬接觸表面的摩擦力。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 值範圍：0 到無窮大。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 例如，coulombFriction 0.5 表示中等摩擦力，0 表示無摩擦（完全滑動）。 \xa0\xa0\xa0 bounce \xa0\xa0\xa0\xa0\xa0\xa0\xa0 定義反彈係數（或恢復係數），決定物體在碰撞後的彈性程度。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 值範圍：0（無反彈）到 1（完全彈性碰撞）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 例如，bounce 0.8 表示接觸後物體反彈很高。 \xa0\xa0\xa0 bounceVelocity \xa0\xa0\xa0\xa0\xa0\xa0\xa0 定義啟用反彈的最小碰撞速度（m/s）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 如果碰撞速度低於此值，則不會有彈性反彈。 \xa0\xa0\xa0 softERP \xa0\xa0\xa0\xa0\xa0\xa0\xa0 決定接觸的彈性修復因子（Error Reduction Parameter）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 用於模擬柔性接觸的效果，值通常在 0 到 1 之間。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 較高的值會讓接觸點更剛硬。 \xa0\xa0\xa0 softCFM \xa0\xa0\xa0\xa0\xa0\xa0\xa0 定義接觸的柔性參數（Constraint Force Mixing）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 用於模擬柔性接觸的效果，較高的值會讓接觸點更柔軟。 3. 使用範例 以下是一個模擬木材與金屬之間的接觸屬性的範例： \n ContactProperties {\n  material1 "wood"\n  material2 "metal"\n  coulombFriction 0.3\n  bounce 0.5\n  bounceVelocity 0.2\n  softERP 0.8\n  softCFM 0.01\n} \n 表示： \xa0\xa0\xa0 木材和金屬接觸時的摩擦係數為 0.3。 \xa0\xa0\xa0 有中等程度的反彈，反彈係數為 0.5。 \xa0\xa0\xa0 碰撞速度超過 0.2 m/s 才會發生反彈。 \xa0\xa0\xa0 接觸的彈性修復因子設為 0.8（較剛硬）。 \xa0\xa0\xa0 柔性係數設為 0.01（接觸點稍微柔軟）。 針對籃球與鐵框的 ContactProperties 參數設定: \n ContactProperties {\n  material1 "basketball"\n  material2 "metal"\n  coulombFriction 0.6\n  bounce 0.8\n  bounceVelocity 0.2\n  softERP 0.8\n  softCFM 0.01\n} \n 這表示： \xa0\xa0\xa0 籃球和金屬框接觸時的摩擦係數為 0.6。 \xa0\xa0\xa0 有中等程度的反彈，反彈係數為 0.8。 \xa0\xa0\xa0 碰撞速度超過 0.2 m/s 才會發生反彈。 \xa0\xa0\xa0 接觸的彈性修復因子設為 0.8（較剛硬）。 \xa0\xa0\xa0 柔性係數設為 0.01（接觸點稍微柔軟）。 \n DistanceSensor \n DistanceSensor 節點可以用來模擬通用感測器、紅外線感測器、聲納感測器或雷射測距儀。此裝置的模擬是通過檢測一條或多條感測射線與環境中的物體之間的碰撞進行的。對於通用、聲納和雷射類型的感測器，碰撞發生在 Solid 節點的邊界物體上；而紅外線射線的碰撞檢測則直接使用 Solid 節點本身。 可以通過勾選選單中的 View / Optional Rendering / Show Distance Sensor Rays 來顯示 DistanceSensor 節點的射線。射線上的紅色/綠色過渡表示與邊界物體的交點位置。 \n 對 AI 提問: 使用 webots 建立一個籃框, 當籃球投入時，可以透過 sensor 感測並且計分，應該要如何設置? 使用哪一類型的 sensor? lookup table 如何設置? 回答: 在 Webots 中建立一個可以感測籃球投入並計分的籃框系統，需要以下步驟，包括選擇合適的感測器、設置感測邏輯以及配置 lookup table。以下是詳細的實現指南： 1. 建立籃框與籃球模型 \xa0\xa0\xa0 籃框模型： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 使用 Webots 的 Solid 節點建立籃框，包含籃圈和籃網。可以透過 Cylinder 節點製作籃圈，搭配 Mesh 或 Shape 節點模擬籃網。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 確保籃框具有物理屬性（Physics 節點），以便與籃球發生碰撞。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 在籃圈下方設置一個感測區域，用於檢測籃球是否通過。 \xa0\xa0\xa0 籃球模型： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 使用 Sphere 節點建立籃球，設置適當的質量和摩擦係數（在 Physics 和 ContactProperties 中）。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 確保籃球的 boundingObject 設置為球形，以便與感測器正確交互。 2. 選擇合適的感測器 為了檢測籃球是否通過籃框，最適合的感測器是 DistanceSensor 或 LightSensor，具體選擇取決於需求： \xa0\xa0\xa0 DistanceSensor（距離感測器）： \xa0\xa0\xa0\xa0\xa0\xa0\xa0 適用場景：用於檢測籃球是否通過特定區域（例如籃圈正下方）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 優點：可以精確測量物體距離，通過設置適當的範圍，能判斷籃球是否進入籃框。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 設置方式： \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 在籃圈正下方放置一個 DistanceSensor，朝上（沿 Z 軸正方向）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 設置感測器的 maxRange 和 minRange，確保只檢測到靠近籃圈的籃球（例如，maxRange 設為 0.5 米，足以覆蓋籃圈內部區域）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 啟用感測器並定期讀取數據，當距離值突然變化（例如從無限遠變為接近籃球半徑）時，判斷為籃球通過。 \xa0\xa0 \xa0 \xa0\xa0\xa0 LightSensor（光感測器）： \xa0\xa0\xa0\xa0\xa0\xa0\xa0 適用場景：模擬光束感測，當籃球通過時阻斷光束，觸發計分。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 優點：模擬真實籃框計分系統（如紅外線感測），邏輯簡單。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 設置方式： \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 在籃圈內部放置一個 LightSensor，搭配一個光源（例如 PointLight），模擬光束。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 設置 occlusion 為 TRUE，確保當籃球通過時阻擋光線，導致感測器輸出值變化。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 當感測器檢測到光強下降（例如從高值降到接近 0），觸發計分。 \xa0\xa0 \xa0 \xa0\xa0\xa0 推薦選擇： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 如果想簡單實現，建議使用 DistanceSensor，因為它更容易設置且邏輯直觀。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 如果需要模擬真實計分系統（類似紅外線），則使用 LightSensor。 3. 設置感測器與計分邏輯 假設選擇 DistanceSensor，以下是具體設置步驟： \xa0\xa0\xa0 感測器節點配置： \xa0\xa0 \xa0 \xa0\xa0\xa0 在 .wbt 檔案中，於籃框下方添加 DistanceSensor： \xa0\xa0\xa0 proto DistanceSensor { \xa0 translation 0 0 -0.1\xa0 # 放置在籃圈下方 10 厘米處 \xa0 rotation 0 1 0 1.57\xa0 # 朝上（沿 Z 軸） \xa0 name "basket_sensor" \xa0 maxRange 0.5\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 感測範圍設為 0.5 米 \xa0 minRange 0.0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 最小範圍 \xa0 fieldOfView 0.1\xa0\xa0\xa0\xa0\xa0 # 窄視場，聚焦籃圈內部 \xa0 lookupTable [ \xa0\xa0\xa0 0.0 1000 0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 距離 0 米時，輸出 1000，無雜訊 \xa0\xa0\xa0 0.1 800 10\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 距離 0.1 米，輸出 800，10% 雜訊 \xa0\xa0\xa0 0.2 400 10\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 距離 0.2 米，輸出 400，10% 雜訊 \xa0\xa0\xa0 0.5 0 0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 距離 0.5 米，輸出 0，無雜訊 \xa0 ] } 計分邏輯： \xa0\xa0\xa0 使用控制器（例如 C 或 Python）讀取感測器數據。 \xa0\xa0\xa0 當感測器輸出值從低值（表示無物體）突然跳到高值（表示檢測到籃球），並在短時間內回到低值，視為一次有效進球。 \xa0\xa0 \xa0 為避免重複計分，設置一個冷卻時間（例如 1 秒），確保每次進球只計分一次。 示例控制器（Python）： python \xa0\xa0\xa0 from controller import Robot, DistanceSensor \xa0\xa0\xa0 robot = Robot() \xa0\xa0\xa0 timestep = int(robot.getBasicTimeStep()) \xa0\xa0\xa0 sensor = robot.getDevice("basket_sensor") \xa0\xa0\xa0 sensor.enable(timestep) \xa0\xa0\xa0 score = 0 \xa0\xa0\xa0 last_score_time = 0 \xa0\xa0\xa0 cooldown = 1.0\xa0 # 冷卻時間 1 秒 \xa0\xa0\xa0 while robot.step(timestep) != -1: \xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance_value = sensor.getValue() \xa0\xa0\xa0\xa0\xa0\xa0\xa0 current_time = robot.getTime() \xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 假設進球時感測器輸出值 > 500 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 if distance_value > 500 and (current_time - last_score_time) > cooldown: \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 score += 2\xa0 # 每次進球加 2 分 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_score_time = current_time \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print(f"進球！目前得分: {score}") 4. Lookup Table 設置 lookupTable 用於將感測器的原始測量值（例如距離）映射到用戶定義的輸出值，並可添加雜訊。對於 DistanceSensor，lookupTable 的格式為 [距離 輸出值 雜訊標準差]： \xa0\xa0\xa0 設計原則： \xa0\xa0\xa0\xa0\xa0\xa0\xa0 第一列（距離）應按升序排列，表示測量到的距離（單位：米）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 第二列（輸出值）是感測器返回的值，通常根據距離減小（距離越近，輸出值越大）。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 第三列（雜訊標準差）表示輸出值的雜訊程度（百分比），通常設為 0 或小值以確保穩定性。 \xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 示例 Lookup Table： \xa0\xa0\xa0 proto \xa0\xa0\xa0 lookupTable [ \xa0\xa0\xa0\xa0\xa0 0.0 1000 0\xa0\xa0\xa0 # 距離 0 米，輸出 1000，無雜訊 \xa0\xa0\xa0\xa0\xa0 0.1 800 10\xa0\xa0\xa0 # 距離 0.1 米，輸出 800，10% 雜訊 \xa0\xa0\xa0\xa0\xa0 0.2 400 10\xa0\xa0\xa0 # 距離 0.2 米，輸出 400，10% 雜訊 \xa0\xa0\xa0\xa0\xa0 0.5 0 0\xa0\xa0\xa0\xa0\xa0\xa0 # 距離 0.5 米或以上，輸出 0，無雜訊 \xa0\xa0\xa0 ] \xa0\xa0\xa0\xa0\xa0\xa0\xa0 解釋： \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 當籃球非常靠近感測器（距離接近 0），輸出高值（1000），表示檢測到籃球。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 當距離增加到 0.5 米或更遠，輸出 0，表示無物體。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 適當的雜訊（10%）模擬真實感測器的誤差，但不影響計分邏輯。 \xa0\xa0 \xa0 \xa0\xa0\xa0 調整建議： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 根據實際籃球尺寸（標準籃球直徑約 0.24 米），確保 lookupTable 涵蓋籃球可能出現的距離範圍。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 如果感測器輸出值變化不明顯，可增加輸出值的範圍（例如從 1000 提高到 2000）以提高檢測靈敏度。 5. 其他注意事項 \xa0\xa0\xa0 物理模擬： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 確保籃球和籃框的 Physics 參數設置正確（例如，適當的質量、彈性係數），以模擬真實的投籃動作。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 使用 ContactProperties 調整籃球與籃框的摩擦力和彈性，避免籃球卡住或反彈異常。 \xa0\xa0 \xa0 \xa0\xa0\xa0 環境設置： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 在 WorldInfo 中設置適當的 basicTimeStep（例如 16 毫秒），確保模擬流暢且感測器數據更新及時。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 添加地板和牆壁（Solid 節點），模擬真實籃球場環境。 \xa0\xa0 \xa0 \xa0\xa0\xa0 調試與測試： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 使用 Webots 的 3D 視圖檢查感測器是否正確檢測籃球。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 透過控制器輸出感測器值（例如 print(sensor.getValue())），驗證 lookupTable 是否按預期工作。 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 模擬多次投籃，確保計分邏輯穩定，無重複計分或漏計。 6. 替代方案 如果 DistanceSensor 的效果不理想，可以考慮以下替代方案： \xa0\xa0\xa0 TouchSensor：將籃網模擬為一個觸碰感測器，當籃球接觸籃網時觸發計分。但這需要精確的碰撞檢測，可能增加模擬複雜度。 \xa0\xa0\xa0 Camera：使用攝影機識別籃球通過籃圈，但這需要圖像處理，實現較為複雜，適合進階應用。 總結 \xa0\xa0\xa0 推薦感測器：DistanceSensor，放置在籃圈下方，朝上檢測籃球。 \xa0\xa0\xa0 Lookup Table 配置：設置距離範圍 0 到 0.5 米，輸出值從 1000 遞減到 0，適當添加雜訊。 \xa0\xa0\xa0 計分邏輯：當感測器輸出值跳變（例如 > 500）且滿足冷卻時間，計分 +2。 \xa0\xa0 \xa0 \xa0\xa0\xa0 關鍵步驟： \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 建立籃框和籃球模型。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 添加並配置 DistanceSensor。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 編寫控制器實現計分邏輯。 \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 測試並優化 lookupTable 和物理參數。 \n', 'tags': '', 'url': 'Nodes.html'}, {'title': 'Stream', 'text': 'https://cyberbotics.com/doc/guide/web-streaming   \n', 'tags': '', 'url': 'Stream.html'}, {'title': 'Webots Server', 'text': 'Webots Server: \n https://github.com/mdecycu/webots-server \n Webots Cloud: \n https://github.com/cyberbotics/webots-cloud   \n https://cyberbotics.com/doc/guide/web-server  ', 'tags': '', 'url': 'Webots Server.html'}, {'title': 'Solvespace', 'text': 'Web-based Solvespace:  https://cad.apps.dgramop.xyz/  ( source  and  PR ) \n Python related PR \n 在\xa0 python_2025_lite.7z \xa0加入以下說明的 msys2 與 cmake 後, 可用來編譯 Solvespace v3.1 版原始碼的可攜套件  python_2025_lite_w_msys_cmake_solvespace.7z \xa0(Download 1.96GB, After extracted 3.7GB) \n \n Solvespace 採 C++ 編寫, 原始碼位於\xa0 https://github.com/solvespace/solvespace , 以下將採用可攜程式系統 python_2025 中的 msys2 ( msys64_20240507.7z ) 以及 cmake 3.20.1 進行編譯 (若採用目前最新版的 cmake 3.30.2, 必須對 Solvespace v3.1 中的 CMakeLists.txt 進行修改). \n 舊版的 cmake 3.21.0 可以利用下列連結取得: \n https://github.com/Kitware/CMake/releases/download/v3.21.0/cmake-3.21.0-windows-x86_64.zip \xa0 \n msys64_20240507.7z  (下載到 data 目錄下後, 目錄名稱必須改為 msys64) 則必須安裝 mingw32-make: \n (安裝以下 make 套件前, 必須先執行 msys64 中的 mingw64.exe) \n pacman -S mingw-w64-ucrt-x86_64-make \n 最新版的 python_2025 可攜程式環境架構位於:  https://github.com/mdecycu/pyhton_2025 , 各目錄套件可自行根據  https://mde.tw/cad2024/content/Python.html  中的說明下載, 或者自行配置. \n 機械設計工程師採用可攜程式套件的原因, 是希望能彈性配置 Python 版本, 因為大多數主流 CAD/E/M 套件都非開源軟體, 各版本的 API 相關的動態連結程式庫, 都採用特定的 Python 版本程式碼編譯而成. 例如: Siemens NX12 採用 Python 3.6.5, NX1872 採用 Python 3.7.1, NX1980 採用 Python 3.8.8, NX2312 使用 Python 3.10.12. 假如採用可攜程式套件, 除了可以如虛擬 Python 環境一樣, 將能配合 NXOpen 程式開發, 將所需的 Python 版本與相關模組放在同一目錄, 且能夠在不同的 64 位元 Windows 操作系統中執行. \n 接著取得 Solvespace v3.1 的原始碼, 可以直接從\xa0 https://github.com/solvespace/solvespace/releases \xa0取得, 或以\xa0以 git clone --recurse-submodules  https://github.com/solvespace/solvespace.git \xa0之後, \n cd solvespace \n git checkout v3.1 \n 接下來則必須修改\xa0solvespace\\extlib\\angle\\src\\libANGLE\\HandleAllocator.cpp 加入標頭檔案: \n #include <limits> \n 接著就可以進行程式碼的編譯與連結: \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release \n mingw32-make \n 完成編譯後, solvespace.exe 即位於 build\\bin 目錄中, 執行時則需要\xa0libwinpthread-1.dll 動態連結程式庫. \n 進行上述流程編譯的原始碼\xa0 solvespace_v3.1_src.7z , 以及編譯完成的  solvespace_v3.1_msys2.7z .', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Learn_Solvs', 'text': 'https://youtu.be/IlY1YFid8HA?si=bbryzq7P-Z_vR9Rc \n https://chromamine.com/2024/07/3d-cad-with-solvespace/ \n https://thenybble.de/posts/solvespace-mini-tutorial/  \n Solvespace Tutorial \n Solvespace Challenge  ( 2 ) \n', 'tags': '', 'url': 'Learn_Solvs.html'}, {'title': 'Pyslvs-UI', 'text': "https://github.com/KmolYuan/Pyslvs-UI \n https://github.com/KmolYuan/pyslvs  (A no-GUI module of mechanism synthesis system and a 2D geometric constraint solver) \n 開發 Pyslvs-UI:  https://github.com/mdecycu/Pyslvs-UI \n 使用 Leo Editor: \n '''Recursively import all python files in a directory and clean the result.'''\n# ctrl + b to execute\n \nc.recursiveImport(\n    dir_ = r'./',\n    kind = '@clean', # The new best practice.\n    safe_at_file = False,\n    theTypes = ['.py']\n) \n 相關 AI 套件:  https://github.com/mdecycu/LInK \n https://arxiv.org/pdf/2405.20592  (LInK: Learning Joint Representations of Design and Performance Spaces through Contrastive Learning for Mechanism Synthesis) \n pytorch_ex1.py \n", 'tags': '', 'url': 'Pyslvs-UI.html'}, {'title': 'PICSimLab', 'text': 'https://github.com/lcgamboa/picsimlab \n', 'tags': '', 'url': 'PICSimLab.html'}, {'title': 'Fossil SCM', 'text': 'https://fossil-scm.org \n \n Edit fossil.smm \n', 'tags': '', 'url': 'Fossil SCM.html'}, {'title': 'Leo Editor', 'text': "https://leo-editor.github.io \n Leo Editor 是一個大綱編輯器, 單一節點資料可以透過 clone 放入多個其他節點資料中. \n 可以利用  @clean  節點指令可結合  @others  與指定的檔案內容同步. \n 利用  @path  指定目錄. \n ctrl + i : insert \n ctrl + r : move right \n ctrl + l : move left \n ctrl + u : move up \n ctrl + d : move down \n The execute-script command pre-defines three names: c, g, and p. c is the commander of the outline in which the script executes. g is the leo.core.leoGlobals module, containing dozens of useful functions and classes. p is the position of the presently selected node. \n g.es() 透過 leo.core.leoGlobals g 中的 echo string 方法列印資料. \n 遞迴導入程式碼: \n c.recursiveImport(\n    dir_ = 'path to file or directory',\n    kind = '@clean',        # or '@file' or '@auto'\n    safe_at_file = False,   # True: generate @@clean nodes.\n    theTypes = None,        # Same as ['.py']\n) \n \n", 'tags': '', 'url': 'Leo Editor.html'}, {'title': 'uv', 'text': 'uv 是一個由  Astral  團隊 ( Founder ) 開發的現代 Python 工具，旨在提供更快、更簡單的工作流程，取代傳統的 pip、virtualenv 和 poetry 等工具。以下將全面介紹其核心功能、高級用法及使用場景。 \n 使用 uv python list 可以列出能夠下載使用的 Python 版本: \n Y:\\>uv python list\ncpython-3.14.0a5+freethreaded-windows-x86_64-none    <download available>\ncpython-3.14.0a5-windows-x86_64-none                 <download available>\ncpython-3.13.2+freethreaded-windows-x86_64-none      <download available>\ncpython-3.13.2-windows-x86_64-none                   y:\\Python313\\python.exe\ncpython-3.13.2-windows-x86_64-none                   <download available>\ncpython-3.12.9-windows-x86_64-none                   <download available>\ncpython-3.11.11-windows-x86_64-none                  <download available>\ncpython-3.10.16-windows-x86_64-none                  <download available>\ncpython-3.9.21-windows-x86_64-none                   <download available>\ncpython-3.8.20-windows-x86_64-none                   <download available>\ncpython-3.7.9-windows-x86_64-none                    <download available>\npypy-3.11.11-windows-x86_64-none                     <download available>\npypy-3.10.16-windows-x86_64-none                     <download available>\npypy-3.9.19-windows-x86_64-none                      <download available>\npypy-3.8.16-windows-x86_64-none                      <download available>\npypy-3.7.13-windows-x86_64-none                      <download available> \n 確認可用的 Python 版本後, 可以透過  Portable  頁面中的流程自行建立可攜 Python 程式套件. \n 接下來應該要探討 uv 在可攜程式環境中的應用. \n', 'tags': '', 'url': 'uv.html'}, {'title': 'Old', 'text': '以下連結僅能在系統主幹的網路 IPv6 協定下擷取: \n cd2019 \n vrml97specification.pdf  (1997) \n vrml_primer_tutorial.pdf  (1998) \n WeBots_2002_guide.pdf \n Aibo and Webots_Simulation, wireless remote control and controller transfer.pdf  (2006) \n Design and Assessment of a Robot Curriculum based on the E-puck Robot and Webots.pdf  (2009) \n Cyberbotics Robot Curriculum.pdf \xa0(2010) \n webots_2010_ex1.pdf \n Webots_2011_guide.pdf \n Webots_2012_guide.pdf \n Improving support for e-puck robot in Webots mobile robots simulation software.pdf  (2012) \n Development of Microphone and Speaker models in Webots using OpenAL.pdf  (2012) \n Interfacing an Android-based phone-robot with Webots.pdf  (2012) \n Mobile Robot modeling, Simulation and Programming.pdf  (2013) \n Mobile Robot modeling Simulating and Programming_New ASIMO.pdf  (2014) \n ROS interface and URDF parser for Webots.pdf  (2014) \n Webots_2014_guide.pdf \n cd2020 \n cd2021 \n cd2022 \n cd2023 \n cd2024 \n \n', 'tags': '', 'url': 'Old.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n \n \n', 'tags': '', 'url': 'Brython.html'}]};